#
# Copyright (c) 2010 Linagora
# Patrick Guiran <pguiran@linagora.com>
# http://github.com/Tauop/sshGate
#
# sshGate is free software, you can redistribute it and/or modify
# it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# sshGate is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# README ---------------------------------------------------------------------
#
# Collection of all targets related functions
#
# ----------------------------------------------------------------------------

if [ "${__SSHGATE_CORE__}" != 'Loaded' ]; then
  echo "ERROR: Only sshgate.core can load user.func."; exit 1;
fi

if [ "${__TARGET_FUNC__:-}" != 'Loaded' ]; then
  __TARGET_FUNC__='Loaded'

  # usage: TARGETS_LIST
  # desc: list all targets, whose name match <pattern> if given
  TARGETS_LIST () {
    local res= find_opt=
    [ $# -eq 1 ] && find_opt="-iname '$1'"

    res=$( eval "find '${SSHGATE_DIR_TARGETS}' -mindepth 1 -type d ${find_opt} -printf '%P\n'" )
    echo "${res}" | sort -u
    return 0;
  }

  # usage: TARGET_ADD [<login>@]<target_host> [ [<login>@]<proxy> ]
  # desc: add a target host
  # note: it will add the ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN} login to target
  # note: it will try to install public sshket to the target authorized_keys2
  # note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
  # important: need to be root to be able to chown ssh priv key
  TARGET_ADD () {
    local target= privsshkey= tmp_file= proxy= proxy_login= reply= target_privsshkey= target_pubsshkey=
    if [ $# -lt 1 -a $# -gt 3 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( GET_HOST "$1" )
    login=$( GET_LOGIN "$1" )
    if [ -z "${target}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [    -d "${SSHGATE_DIR_TARGETS}/${target}" \
         -o -L "${SSHGATE_DIR_TARGETS}/${target}" ]; then
      ERROR "Target or Alias '${target}' already exist"; return 1;
    fi

    if [ $# -eq 2 ]; then
      proxy=$( GET_HOST "$2" )
      proxy_login=$( GET_LOGIN "$2" )
      proxy=$( TARGET_REAL "${proxy}" )
      if [ -z "${proxy}" ]; then
        ERROR "Proxy target host '${proxy}' doesn't exist"; return 1;
      fi
    fi


    # check that the host exists (DNS/IP)
    if [ -z "${proxy}" ]; then
      ping -c 1 "${target}" >/dev/null 2>/dev/null
    else
      TARGET_SSH_RUN_COMMAND "${login}@${proxy}" "ping -c 1 '${target}' >/dev/null 2>/dev/null"
    fi
    if [ $? -ne 0 ]; then
      echo "Warning: Unable to ping ${target} !";
      ASK --yesno reply 'Continue [Y] ? '
      if [ "${var}" = 'N' ]; then
        ERROR "Adding '${target}' stoped"; return 1;
      fi
    fi

    ASK --yesno reply 'Use the sshGate default sshkey for this target host [Y] ? '
    if [ "${reply}" = 'N' ]; then
      privsshkey="/tmp/sshkey.$(RANDOM)"
      tmp_file="/tmp/sshkey.$(RANDOM)"

      echo "# Put the private sshkey for '${target}' here. Then save & quit from the editor" >> "${privsshkey}"
      echo "# Allow line begins by '#' will be removed"                                      >> "${privsshkey}"
      eval " ${SSHGATE_EDITOR} '${privsshkey}'"

      grep -v '^#' < "${privsshkey}" > "${tmp_file}"
      mv "${tmp_file}" "${privsshkey}"
    fi

    target_privsshkey="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PRIVATE_SSHKEY_FILENAME}"
    target_pubsshkey="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PUBLIC_SSHKEY_FILENAME}"

    # create the target now
    mkdir -p "${SSHGATE_DIR_TARGETS}/${target}"
    [ -n "${proxy}" ] && TARGET_SET_CONF "${target}" SSH_PROXY "${proxy_login}@${proxy}"

    if [ -n "${privsshkey}" ]; then
      mv "${privsshkey}" "${target_privsshkey}"
      chmod 400 "${target_privsshkey}"
      chown "${SSHGATE_GATE_ACCOUNT}" "${target_privsshkey}"

      # try to generate the public key, to check that the key doesn't have passphrase
      ssh-keygen -y -f "${target_privsshkey}" > "${target_pubsshkey}"
      if [ $? -ne 0 ]; then
        rm -rf "${SSHGATE_DIR_TARGETS}/${target}"
        ERROR "Unable to generate public ssh key." ; return 1;
      fi
      chown "${SSHGATE_GATE_ACCOUNT}" "${target_pubsshkey}"
    # else use the default sshpriv key
    fi

    TARGET_SSH_ADD_LOGIN "${target}" "${login}"
    private_ADD_TARGET_TO_KNOWN_HOST "${target}"
    if [ $? -ne 0 ]; then
      echo "NOTICE: Can't add identity of host in know_hosts file. Use 'build known_hosts' to add it manually"
      echo "NOTICE: Public ssh key of '${target}' can't be installed on '${login}@${target}'. Install it manually"
    else
      TARGET_SSH_INSTALL_KEY "${target}" "${login}"
    fi

    private_MAIL_APPEND "Target ${login}@${target} added"

    return 0;
  }

  # usage: TARGET_DEL <target_host>
  # desc: Delete a target host
  TARGET_DEL () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1
    fi

    private_DELETE_TARGET_FROM_KNOWN_HOST "${target}"

    for alias in $( TARGET_LIST_ALIASES "${target}" ); do
      rm -f "${SSHGATE_DIR_TARGETS}/${alias}"
    done

    rm -rf "${SSHGATE_DIR_TARGETS}/${target}"

    private_MAIL_APPEND "Target ${target} removed"

    return 0;
  }

  # usage: TARGET_RENAME <target_host> <new_name>
  # desc: Rename a target host and create an alias with the old target name
  TARGET_RENAME () {
    local target= target_port= new_name= new_target=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target=$( TARGET_REAL "$1" ); new_name="$2"; new_target=$( TARGET_REAL "${new_name}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1;
    fi
    if [ "${target}" != "$1" ]; then
      ERROR "Target name '$1' is an alias of '${target}'"; return 1;
    fi
    if [ -n "${new_target}" ]; then
      ERROR "Target name '${new_name}' already used"; return 1;
    fi

    mv "${SSHGATE_DIR_TARGETS}/${target}" "${SSHGATE_DIR_TARGETS}/${new_name}"
    [ -d "${SSHGATE_DIR_LOG}/${target}/" ] && mv "${SSHGATE_DIR_LOG}/${target}" "${SSHGATE_DIR_LOG}/${new_name}"
    echo "Target renamed : ${target} -> ${new_name}"

    TARGET_ADD_ALIAS "${new_name}" "${target}"
    echo "Target alias '${target}' created"

    target_port=$( private_TARGET_SSH_GET_CONFIG_FILE "${target}" $(GET_LOGIN "${target}") | grep 'Port' \
                   | sed -e 's/^[^0-9]*\([0-9]*\)[^0-9]*$/\1/' )
    target_port="${target_port:-22}"
    private_ADD_TARGET_TO_KNOWN_HOST "${new_name}" "${target_port}"
    private_MAIL_APPEND "Target ${target} renamed to ${new_name}"

    return 0;
  }

  # usage: TARGET_DISPLAY_CONF <target>
  # desc: Display the configuration file of the target
  TARGET_DISPLAY_CONF () {
    local target= file=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    if [ ! -f "${file}" ]; then
      NOTICE "Target host '${target}' has no configuration file"
    else
      cat "${file}"
    fi
    return 0
  }

  # usage: TARGET_SET_CONF <target> <variable> [ <value> ]
  # desc: Set a variable/value pair into the target configuration file
  # note: if no <value> is given, the <variable> is removed from the
  #       configuration file of the <target>
  TARGET_SET_CONF () {
    local target= var= value= file=
    if [ $# -lt 2 -o $# -gt 3 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target="$1"; var="$2"
    [ $# -eq 3 ] && value="$3"

    if [ -z "${target}" -o -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    if [ -n "${value}" ]; then
      [ ! -f "${file}" ] && touch "${file}"
      CONF_SAVE --conf-file "${file}" "${var}" "${value}"
      private_MAIL_APPEND "Target '${target}' configuration: ${var} = ${value}"
    else
      CONF_DEL --conf-file "${file}" "${var}"
      private_MAIL_APPEND "Target '${target}' configuration: ${var} removed"
    fi

    [ -f "${file}" ] && chmod a+r "${file}" # ensure file permissions
    return 0;
  }

  TARGET_DEL_CONF () {
    local target= var= file=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target="$1"; var="$2"
    if [ -z "${target}" -o -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    CONF_DEL --conf-file "${file}" "${var}"
    [ -f "${file}" ] && chmod a+r "${file}" # ensure file permissions

    private_MAIL_APPEND "Target '${target}' configuration: ${var} removed"
    return 0;
  }

  # usage: TARGET_GET_CONF <target> <variable>
  # desc: Get the <variable> value from the target configuration file
  TARGET_GET_CONF () {
    local target= var= file=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; var="$2"
    target=$( GET_HOST "${target}" )
    target=$( TARGET_REAL "${target}" )

    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    if [ -f "${file}" ]; then
      CONF_GET --conf-file "${file}" "${var}"
      eval "echo \"\${${var}}\""
    fi
    return 0;
  }

  # usage: private_TARGET_SSH_GET_CONFIG_FILE <target> <login>
  # desc: Echo-return the file path to the ssh configuration file of the target
  private_TARGET_SSH_GET_CONFIG_FILE () {
    local target= login= file=

    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; login="$2"
    file="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.${login}"

    [ ! -f "${file}" ] && touch "${file}"
    echo "${file}"
    return 0;
  }

  # usage: TARGET_SSH_EDIT_CONFIG <target> [ <login> ]
  # usage: TARGET_SSH_EDIT_CONFIG [<login>@<target>]
  # desc: Edit the ssh configuration file of the <target> for <login>
  # note: if <login> is not given, try to use default ssh login of the target
  #       host, or the sshGate target's default ssh login
  # note: if <target> is egal to "all", edit the global ssh configuration for
  #       "Host *". In this case, we don't care about <login>.
  TARGET_SSH_EDIT_CONFIG () {
    local target= login= file= tmpfile= bckfile=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ "$1" != 'all' ]; then
      if [ $# -eq 1 ]; then
        target=$( GET_HOST "$1" )
        login=$( GET_LOGIN "$1" )
      else
        target="$1"; login="$2"
      fi

      target=$( TARGET_REAL "${target}" )
      if [ -z "${target}" ]; then
        ERROR "Target host '${target} doesn't exist"; return 1;
      fi

      [ -z "${login}" ] && login=$( GET_LOGIN "${target}" )
      if [ "${login}" != "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ]; then
        # check that the login exist for the target host
        TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}\$" >/dev/null
        if [ $? -ne 0 ]; then
          ERROR "Login '${login}' doesn't exist for the target host '${target}'"
          return 1;
        fi
      fi

      file=$( private_TARGET_SSH_GET_CONFIG_FILE "${target}" "${login}" )
    else
      file="${SSHGATE_DIR_DATA}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.all"
    fi # end of : if [ "${target}" != 'all' ]; then

    [ ! -f "${file}" ] && touch "${file}"

    # backup configuration
    bckfile="${file}.bak"
    cp "${file}" "${bckfile}"

    # edit the file
    eval "${SSHGATE_EDITOR} '${file}'"

    tmpfile="/tmp/ssh_config.${login}.$( RANDOM )"

    # filter out some options and warn if they are used
    for opt in 'BatchMode'                \
               'CheckHostIP'              \
               'ControlMaster'            \
               'ControlPath'              \
               'ForwardAgent'             \
               'IdentityFile'             \
               'PreferredAuthentications' \
               'ProxyCommand'             \
               'StrictHostKeyChecking'    \
               'User'                     \
               'UserKnownHostsFile' ; do
      grep "^[[:space:]]*${opt}[[:space:]]" < "${file}" >/dev/null
      if [ $? -eq 0 ]; then
        echo "WARNING: ssh options '${opt}' was removed from editable configuration file. It's not allowed or deal by sshGate"
        grep -v "^[[:space:]]*${opt}[[:space:]]" < "${file}" > "${tmpfile}"
        mv "${tmpfile}" "${file}"
      fi
    done

    rm -f "${tmpfile}"

    # permissions
    chown "${SSHGATE_GATE_ACCOUNT}" "${file}"
    chmod ug+r "${file}"

    return 0;
  }

  # usage: TARGET_SSH_GET_CONFIG <target> [ <login> ]
  # usage: TARGET_SSH_GET_CONFIG [<login>@]<target>
  # desc: Get generated ssh configuration file used to connect to the target
  # note: if <login> is not given, try to use default ssh login of the target
  #       host, or the sshGate target's default ssh login
  TARGET_SSH_GET_CONFIG () {
    local target= login= proxy= proxy_host= proxy_login= file= tmpfile= known_hosts_file= sshkey_file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target} doesn't exist"; return 1;
    fi

    [ -z "${login}" ] && login=$( GET_LOGIN "${target}" )
    if [ "${login}" != "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ]; then
      # check that the login exist for the target host
      TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}\$" >/dev/null
      if [ $? -ne 0 ]; then
        ERROR "Login '${login}' doesn't exist for the target host '${target}'"
        return 1;
      fi
    fi

    file=$( private_TARGET_SSH_GET_CONFIG_FILE "${target}" "${login}" )
    known_hosts_file="$( SSHGATE_ACCOUNT_HOMEDIR )/.ssh/known_hosts"
    sshkey_file=$( private_TARGET_PRIVATE_SSHKEY_FILE "${target}" )
    tmpfile="/tmp/ssh_config.$( RANDOM )"

    proxy=$( TARGET_GET_CONF "${target}" SSH_PROXY )
    if [ -n "${proxy}" ]; then
      proxy_host=$( GET_HOST "${proxy}" )
      proxy_host=$( TARGET_REAL "${proxy_host}" )
      proxy_login=$( GET_LOGIN "${proxy}" )
      if [ -z "${proxy_host}" ]; then
        ERROR "Target '${target}' was declared to need proxy target '${proxy_host}' whereas '${proxy_host}' doesn't exist";
        return 1;
      else
        tmpfile=$( TARGET_SSH_GET_CONFIG "${proxy_host}" "${proxy_login}" )
      fi
    else
      # no proxy, but have to get the global ssh configuration
      echo "Host *"                                                      >> "${tmpfile}"
      echo " IdentityFile ${SSHGATE_TARGET_DEFAULT_PRIVATE_SSHKEY_FILE}" >> "${tmpfile}"
      echo " IdentitiesOnly yes"                                         >> "${tmpfile}"
      echo " StrictHostKeyChecking yes"                                  >> "${tmpfile}"
      echo " HashKnownHosts no"                                          >> "${tmpfile}"
      echo " UserKnownHostsFile ${known_hosts_file}"                     >> "${tmpfile}"
      if [ -r "${SSHGATE_DIR_DATA}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.all" ]; then
        cat "${SSHGATE_DIR_DATA}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.all" >> "${tmpfile}"
      fi
    fi # end of : if [ -n "${proxy}" ]; then

    echo                                           >> "${tmpfile}"
    echo "Host ${target}"                          >> "${tmpfile}"
    echo " IdentityFile ${sshkey_file}"            >> "${tmpfile}"
    echo " IdentitiesOnly yes"                     >> "${tmpfile}"
    echo " StrictHostKeyChecking yes"              >> "${tmpfile}"
    echo " User ${login}"                          >> "${tmpfile}"
    if [ -n "${proxy}" ]; then
      echo " ProxyCommand ssh -F ${tmpfile} ${proxy} nc %h %p" >> "${tmpfile}"
    fi
    cat "${file}"                                            >> "${tmpfile}"

    echo "${tmpfile}"
    return 0;
  }

  # usage: TARGET_SSH_DISPLAY_GLOBAL_CONFIG
  # desc: Display global ssh configuration file used, which declare options for "Host *"
  TARGET_SSH_DISPLAY_GLOBAL_CONFIG () {
    local file="${SSHGATE_DIR_DATA}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.all"
    [ -f "${file}" ] && cat "${file}"
    return 0;
  }

  # usage: TARGET_SSH_DISPLAY_CONFIG <target> [ <login> ]
  # usage: TARGET_SSH_DISPLAY_CONFIG [<login>@]<target>
  # desc: Display simple ssh configuration file used to connect to <target> with <login>
  # note: if <login> is not given, try to use default ssh login of the target
  #       host, or the sshGate target's default ssh login
  TARGET_SSH_DISPLAY_CONFIG () {
    local target= login= file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" );
      login=$( GET_LOGIN "$1" );
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target} doesn't exist"; return 1;
    fi

    [ -z "${login}" ] && login=$( GET_LOGIN "${target}" )
    if [ "${login}" != "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ]; then
      # check that the login exist for the target host
      TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}\$" >/dev/null
      if [ $? -ne 0 ]; then
        ERROR "Login '${login}' doesn't exist for the target host '${target}'"
        return 1;
      fi
    fi

    file=$( private_TARGET_SSH_GET_CONFIG_FILE "${target}" "${login}" )
    cat "${file}"
    return 0;
  }

  # usage: TARGET_SSH_DISPLAY_FULL_CONFIG <target> [ <login> ]
  # usage: TARGET_SSH_DISPLAY_FULL_CONFIG [<login>@]<target>
  # desc: Display full generated ssh configuration file used to connect to the target
  # note: if <login> is not given, try to use default ssh login of the target
  #       host, or the sshGate target's default ssh login
  TARGET_SSH_DISPLAY_FULL_CONFIG () {
    local target= login= file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target} doesn't exist"; return 1;
    fi

    [ -z "${login}" ] && login=$( GET_LOGIN "${target}" )
    if [ "${login}" != "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ]; then
      # check that the login exist for the target host
      TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}\$" >/dev/null
      if [ $? -ne 0 ]; then
        ERROR "Login '${login}' doesn't exist for the target host '${target}'"
        return 1;
      fi
    fi

    file=$( TARGET_SSH_GET_CONFIG "${target}" "${login}" )
    # sed is needed to remove reference of the temporary generated file
    cat "${file}" | sed -e "s|${file}|ssh_conf_file|g";
    rm -f "${file}"
    return 0;
  }

  # usage: TARGET_SSH_LIST_LOGINS <target>
  # desc: List all avariable ssh logins of target
  TARGET_SSH_LIST_LOGINS () {
    local target= file=
    if [ $# -ne 1 ]; then
     BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_SSH_LOGINS_FILENAME}"
    ( [ -f "${file}" ] && cat "${file}";
      TARGET_GET_CONF "${target}" DEFAULT_SSH_LOGIN ) | grep -v '^$' | sort -u
    return 0;
  }

  # usage: TARGET_SSH_ADD_LOGIN <target> <login>
  # desc: Add a ssh login to the target
  TARGET_SSH_ADD_LOGIN () {
    local target= file= login=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; login="$2"
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_SSH_LOGINS_FILENAME}"
    if [ ! -f "${file}" ]; then
      touch "${file}"
    else
      grep "^${login}$" < "${file}" >/dev/null
      if [ $? -eq 0 ]; then
        ERROR "Login '${login}' already exists for target '${target}'"; return 1;
      fi
    fi # end of : if [ ! -f "${file}" ]; then

    echo "${login}" >> "${file}"
    # create empty access files
    touch "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    touch "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}"

    return 0;
  }

  # usage: TARGET_SSH_DEL_LOGIN <target> <login>
  # desc: Remove a ssh l_DELogin from the target
  TARGET_SSH_DEL_LOGIN () {
    local target= login= file= tmp_file=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; login="$2"
    [ "${login}" = "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ] && return 0;

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_SSH_LOGINS_FILENAME}"
    tmp_file="/tmp/file.$( RANDOM )"

    [ ! -e "${file}" ] && return 0;
    grep -v  "^${login}$" < "${file}" > "${tmp_file}"
    mv "${tmp_file}" "${file}"

    # delete access files
    rm -f "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    rm -f "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}"

    return 0;
  }

  # usage: TARGET_SSH_USE_DEFAULT_KEY <target_host>
  # desc: Set default sshkey for a target host
  # note: you may have access to the <target_host> with the sshkey of the
  #       root account, or with the your sshkey and sshagent forwarding.
  TARGET_SSH_USE_DEFAULT_KEY () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    sshkey_file=$( private_TARGET_PUBLIC_SSHKEY_FILE "${target}" )
    [ "${sshkey_file}" != "${SSHGATE_TARGET_DEFAULT_PUBLIC_SSHKEY_FILE}" ] && rm -f "${sshkey_file}"

    sshkey_file=$( private_TARGET_PRIVATE_SSHKEY_FILE "${target}" )
    [ "${sshkey_file}" != "${SSHGATE_TARGET_DEFAULT_PRIVATE_SSHKEY_FILE}" ] && rm -f "${sshkey_file}"

    return 0;
  }

  # usage: TARGET_SSH_RUN_COMMAND [<login>@]<target> <remote-command>
  # desc: Execute a command on the remote target host
  # note: if <login> isn't given, use the target's default ssh login
  TARGET_SSH_RUN_COMMAND () {
    local target= login= remote_command= ssh_conf_file= result=
     if [ $# -ne 2 ]; then
       BAD_ARGUMENTS ; return 1;
     fi

     target=$( GET_HOST "$1" )
     login=$( GET_LOGIN "$1" )
     remote_command="$2"
     if [ -z "${target}" ]; then
       ERROR "Target host '${target}' doesn't exist"; return 1;
     fi

     ssh_conf_file=$( TARGET_SSH_GET_CONFIG "${target}" "${login}" )
     [ $? -ne 0 ] && return 1;
     ssh -o "ConnectTimeout 5" \
         -F "${ssh_conf_file}" \
         "${login}@${target}"  \
         "${remote_command}" 2>/dev/null
     result=$?
     rm -f "${ssh_conf_file}"
     return ${result}
  }

  # usage: TARGET_SSH_INSTALL_KEY [<login>@]<target>
  # usage: TARGET_SSH_INSTALL_KEY <target> [<login>]
  # desc: Try to install public sshkey on all targets
  # note: you may have access to the <target> with the sshkey of the
  #       root account, or with the your sshkey and sshagent forwarding.
  # note: if <login> isn't specified, use the target's default ssh login
  TARGET_SSH_INSTALL_KEY () {
    local target= login= sshkey_file= ssh_conf_file=
    if [ $# -ne 1 -a $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    sshkey_file=$( private_TARGET_PUBLIC_SSHKEY_FILE "${target}" )
    if [ -z "${sshkey_file}" ]; then
      ERROR "Unable to find private ssh key of '${target}'" ; return 1;
    fi

    cat "${sshkey_file}"          \
      | TARGET_SSH_RUN_COMMAND "$1" "umask 077; test -d .ssh || mkdir .ssh ; cat >> .ssh/authorized_keys"
    if [ $? -ne 0 ]; then
      echo "NOTICE: Public ssh key of '${target}' can't be installed on '${login}@${target}'. Install it manually"
    fi

    return 0
  }

  # usage: TARGET_SSH_INSTALL_ALL_KEYS
  # desc: Try to install the public sshkey on the target
  # note: you may have access to the <target_host> with the sshkey of the
  #       root account, or with the your sshkey and sshagent forwarding.
  TARGET_SSH_INSTALL_ALL_KEYS () {
    echo "= Install sshkey on all targets ="
    for target in $( TARGETS_LIST ); do
      for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
        echo -n ".  ${login}@${target}  ... "
        TARGET_SSH_INSTALL_KEY "${login}@${target}"
        [ $? eq 0 ] && echo 'OK' || echo 'KO'
      done
    done
    return 0;
  }

  # usage: TARGET_SSH_TEST [<login>@]<target_host>
  # desc: Test to connect to the target
  TARGET_SSH_TEST () {
    local target= login= ssh_conf_file= sshkey_file= reply=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( GET_HOST "$1" )
    login=$( GET_LOGIN "$1" )
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    echo -n "-  ${login}@${target}  ... "
    ssh_conf_file=$( TARGET_SSH_GET_CONFIG "${target}" "${login}" )
    reply=$( ssh -o "ConnectTimeout 5"                       \
                 -o "BatchMode yes"                          \
                 -F "${ssh_conf_file}"                       \
                 "${login}@${target}" "echo 'test'" 2>&1 )
    if [ $? -eq 0 -a "${reply}" = 'test' ]; then
      echo 'OK';
    else
      echo 'KO';
      echo "     ${reply}" | sed -e $'s/\r//';
    fi

    rm -f "${ssh_conf_file}"
    return 0;
  }

  # usage: TARGET_SSH_TEST_ALL
  # desc: Test to connect to all target.
  # important: this take a while to test ssh connection on all target
  TARGET_SSH_TEST_ALL () {
    echo "= Test all targets ssh connectivity ="
    for target in $( TARGETS_LIST ); do
      for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
        TARGET_SSH_TEST "${login}@${target}"
      done
    done
  }

  # usage: TARGET_ACCESS_INFO <target_host>
  # desc: List all user who has access to the target, and how
  TARGET_ACCESS_INFO () {
    local target= login= targetgroup_list= users_list=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    # direct access
    for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
      users_list=$( cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}" | sort -u )
      if [ -n "${users_list}" ]; then
        echo -n "  ${users_list}" | tr $'\n' ','
        echo " ---> ${login}@${target}"
      fi
    done

    # access through usergroup
    for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
      for usergroup in $( TARGET_ACCESS_LIST_USERGROUPS "${target}" "${login}" ); do
        users_list=$( USERGROUP_LIST_USERS "${usergroup}" )
        if [ -n "${users_list}" ]; then
          echo -n "  ${users_list}" | tr $'\n' ','
          echo " --- usergroup(${usergroup}) ---> ${login}@${target}"
        fi
      done
    done # end of : for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
    return 0;
  }

  # usage: TARGET_LIST_ALIASES [ <target_host> ]
  # desc: List aliases of a target host, or all aliases
  # note: if called without argument, list aliases of all hosts
  TARGET_LIST_ALIASES () {
    local target= t=
    if [ $# -eq 1 ]; then
      target=$( TARGET_REAL "$1" )
      if [ -z "${target}" ]; then
        ERROR "Target host '${target}' doesn't exist" ; return 1;
      fi
    fi

    for file in $( find "${SSHGATE_DIR_TARGETS}/" -type l ); do
      t=$( readlink -f "${file}" )
      [ -z "${target}" -o "${t##*/}" = "${target}" ] && echo "${file##*/}"
    done | sort -u
    return 0;
  }

  # usage: TARGET_ADD_ALIAS <target_host> <alias>
  # desc: Add an alias name to the target host
  TARGET_ADD_ALIAS () {
    local target=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" ); alias="$2"
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1
    fi
    if [ -z "${alias}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -L "${SSHGATE_DIR_TARGETS}/${alias}" ]; then
      ERROR "Target alias '${alias}' already exists" ; return 1
    fi
    if [ -d "${SSHGATE_DIR_TARGETS}/${alias}" ]; then
      ERROR "Target alias '${alias}' correspond to a target host name" ; return 1
    fi

    ln -s "${SSHGATE_DIR_TARGETS}/${target}" "${SSHGATE_DIR_TARGETS}/${alias}"
    return 0;
  }

  # usage: TARGET_DEL_ALIAS <alias>
  # desc: Delete an alias name of a target host
  TARGET_DEL_ALIAS () {
    local alias=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    alias="$1"
    if [ -z "${alias}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ ! -L "${SSHGATE_DIR_TARGETS}/${alias}" ]; then
      ERROR "Target alias '${alias}' doesn't exist" ; return 1;
    fi

    rm -f "${SSHGATE_DIR_TARGETS}/${alias}"
    return 0;
  }

  # usage: TARGET_REAL <target_host>
  # desc: Get the real name of a target host
  # note: if real name is an empty string, the target host doesn't exist
  TARGET_REAL () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( GET_HOST "$1" )
    if [ -z "${target}" ]; then
      echo ''; return 1;
    fi

    if [ -L "${SSHGATE_DIR_TARGETS}/${target}" ]; then
      target=$( readlink -f "${SSHGATE_DIR_TARGETS}/${target}" )
      echo "${target##*/}"
    else
      if [ -d "${SSHGATE_DIR_TARGETS}/${target}" ]; then
        echo "${target}"
      else
        echo ''
        return 1;
      fi
    fi
    return 0;
  }

  # usage: TARGET_ACCESS_LIST_USERS [<login>@]<target_host>
  # usage: TARGET_ACCESS_LIST_USERS <target_host> <login>
  # desc: List users who have access to the target host
  # note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
  TARGET_ACCESS_LIST_USERS () {
    local target= login= files=
    if [ $# -ne 1 -a $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Login '${login}' doesn't exist on target '${target}'"; return 1;
    fi

    files="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"

    # through groups : target -> usergroup -> users
    for usergroup in $( cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}" ); do
      files="${files} ${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"
    done

    cat ${files} | sort -u
    return 0;
  }

  #usage: TARGET_ACCESS_LIST_USERS <target_host>
  #desc: List users who have access to the target host for each ssh login
  TARGET_ACCESS_LIST_ALL_USERS () {
    local target= login=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1;
    fi

    for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
      echo "= ${login}@${target} ="
      TARGET_ACCESS_LIST_USERS "${target}" "${login}"
    done
    return 0;
  }

  # usage: TARGET_ACCESS_ADD_USER [<login>@]<target_host> <user>
  # usage: TARGET_ACCESS_ADD_USER <target_host> <login> <user>
  # desc: Give to the user access to target host
  # note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
  TARGET_ACCESS_ADD_USER () {
    local target= login= user=
    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 2 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
      user="$2"
    else
      target="$1"; login="$2"; user="$3"
    fi

    if [ -z "${user}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Login '${login}' doesn't exist on '${target}'"; return 1;
    fi

    private_ACL_FILE_ADD "${user}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    private_MAIL_APPEND "User ${user} access to Target ${login}@${target} granted"

    return 0;
  }

  # usage: TARGET_ACCESS_DEL_USER [<login>@]<target_host> <user>
  # usage: TARGET_ACCESS_DEL_USER <target_host> <login> <user>
  # desc: Revoke user access to target host
  # note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
  TARGET_ACCESS_DEL_USER () {
    local target= login= user= access_file=
    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1
    fi

    if [ $# -eq 2 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
      user="$2"
    else
      target="$1"; login="$2"; user="$3"
    fi

    if [ -z "${user}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Login '${login}' doesn't exist on target '${target}'"; return 1;
    fi

    private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    private_MAIL_APPEND "User ${user} access to Target ${login}@${target} revoked"

    return 0;
  }

  # usage: TARGET_ACCESS_LIST_USERGROUPS [<login>@]<target_host>
  # usage: TARGET_ACCESS_LIST_USERGROUPS <target_host> <login>
  # desc: List all groups who can access to <login>@<target>
  TARGET_ACCESS_LIST_USERGROUPS () {
    local target= login=
    if [ $# -ne 1 -a $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Login '${login}' doesn't exist on target '${target}'"; return 1;
    fi

    cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}" | sort -u
    return 0;
  }

  # usage: TARGET_ACCESS_LIST_ALL_USERGROUPS <target_host>
  # desc: List all groups who can access to the target host, for each ssh login
  TARGET_ACCESS_LIST_ALL_USERGROUPS () {
    local target= login=

    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1;
    fi

    for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
      echo "= ${login}@${target} ="
      TARGET_ACCESS_LIST_USERGROUPS "${target}" "${login}"
    done
  }

  # usage: TARGET_ACCESS_ADD_USERGROUP [<login>@]<target_host> <user_group>
  # usage: TARGET_ACCESS_ADD_USERGROUP <target_host> <login> <user_group>
  # desc: Give to a usergroup access to a target host
  # note: if <login> is not given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
  TARGET_ACCESS_ADD_USERGROUP () {
    local target= login= usergroup=
    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 2 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
      usergroup="$2"
    else
      target="$1"; login="$2"; usergroup="$3"
    fi

    if [ -z "${usergroup}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_ADD "${usergroup}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}"
    private_MAIL_APPEND "User Group ${usergroup} access to Target ${login}@${target} granted"

    return 0;
  }

  # usage: TARGET_ACCESS_DEL_USERGROUP [<login>@]<target_host> <user_group>
  # usage: TARGET_ACCESS_DEL_USERGROUP <target_host> <login> <user_group>
  # desc: Revoke usergroup access to a target host
  # note: if <login> is not given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
  TARGET_ACCESS_DEL_USERGROUP () {
    local target= login= usergroup=
    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1
    fi

    if [ $# -eq 2 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
      usergroup="$2"
    else
      target="$1"; login="$2"; usergroup="$3"
    fi

    if [ -z "${usergroup}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target  host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_DEL "${usergroup}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}"
    private_MAIL_APPEND "User Group ${usergroup} access to Target ${login}@${target} revoked"

    return 0;
  }

  # usage: TARGET_LOG_FILE <target_host>
  # desc: echo-return the target global log file
  # note: create the target main directory in ${SSHGATGE_DIR_LOG} if needed
  TARGET_LOG_FILE () {
    local target= dir=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      echo ''; return 1;
    fi

    dir="${SSHGATE_DIR_LOG}/${target}"
    [ ! -d "${dir}/" ] && mkdir -p "${dir}/"

    touch "${dir}/global.log"
    echo "${dir}/global.log"
    return 0;
  }

  # usage: TARGET_SESSION_LOG_FILE <target_host> <username>
  # desc: echo-return the target session log file path
  TARGET_SESSION_LOG_FILE () {
    local user= target= f=

    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; user="$2"
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" -o -z "${user}" ]; then
      echo ''; return 1;
    fi

    f="${SSHGATE_DIR_LOG}/${target}/$(date +%Y%m%d%H%M%S).${user}.$$"
    touch "$f"
    echo "$f"
    return 0;
  }

  # usage: private_TARGET_PRIVATE_SSHKEY_FILE <target_host>
  # desc: echo-return the path to the private ssh key of the target host
  private_TARGET_PRIVATE_SSHKEY_FILE () {
    local target= f=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target="$1"
    f="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PRIVATE_SSHKEY_FILENAME}"
    [ ! -r "$f" -o -z "${target}" ] && f="${SSHGATE_TARGET_DEFAULT_PRIVATE_SSHKEY_FILE}"
    echo "$f"
  }

  # usage: private_TARGET_PUBLIC_SSHKEY_FILE <target_host>
  # desc: echo-return the path to the public ssh key of the target host
  private_TARGET_PUBLIC_SSHKEY_FILE () {
    local target= f=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target="$1"
    f="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PUBLIC_SSHKEY_FILENAME}"
    [ ! -r "$f" -o -z "${target}" ] && f="${SSHGATE_TARGET_DEFAULT_PUBLIC_SSHKEY_FILE}"
    echo "$f"
  }

  # usage: DISPLAY_TARGET_PUBLIC_SSHKEY <target_host>
  # desc: Display public sshkey of a target
  DISPLAY_TARGET_PUBLIC_SSHKEY () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1;
    fi
    cat $( private_TARGET_PUBLIC_SSHKEY_FILE "${target}" )
    return 0;
  }

fi # if [ "${__TARGET_FUNC__}" != 'Loaded' ]; then
