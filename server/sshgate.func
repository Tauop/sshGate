#
# Copyright (c) 2010 Linagora
# Patrick Guiran <pguiran@linagora.com>
# http://github.com/Tauop/sshGate
#
# sshGate is free software, you can redistribute it and/or modify
# it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# sshGate is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# README ---------------------------------------------------------------------
# Collection of all need functions to deal with sshgate administrations.
#
# FUNCTIONS ------------------------------------------------------------------
#
# HELP()
#   usage: HELP [ <function_name> ]
#   desc: if called without argument, display all functions usage list.
#         if called with a function_name, display all information about this function
#
# SSHGATE_ACCOUNT_HOMEDIR()
#   usage: SSHGATE_ACCOUNT_HOMEDIR
#   desc: return the home directory of the SSHGATE_GATE_ACCOUNT user
#
# BUILD_AUTHORIZED_KEYS()
#   usage: BUILD_AUTHORIZED_KEYS
#   desc: update the authorized_key2 of the sshGate account
#   important: need to be root to be able to update authorized_keys2 and chown files
#
# BUILD_KNOWN_HOSTS()
#   usage: BUILD_KNOWN_HOSTS
#   desc: update the known_hosts file
#   important: need to be root
#
# ADD_TARGET_TO_KNOWN_HOST()
#   usage: ADD_TARGET_TO_KNOWN_HOST <target> [ <file> ]
#   desc: call ssh-keyscan to the <target> and add the public host sshkey to the <file>
#   note: if <file> is not specified, determine it with SSHGATE_ACCOUNT_HOMEDIR
#
# DELETE_TARGET_FROM_KNOWN_HOST()
#   usage: DELETE_TARGET_FROM_KNOWN_HOST <target> [ <file> ]
#   desc: delete the public host sshkey of the <target> from the known_hosts file
#   note: if <file> is not specified, determine it with SSHGATE_ACCOUNT_HOMEDIR
#
# TARGET_LOG_FILE()
#   usage: TARGET_LOG_FILE [ <target_host> ]
#   desc: echo-return the target global log file
#   note: create the target main directory in ${SSHGATGE_DIR_LOG} if needed
#   note: if called without argument, try to use ${TARGET_HOST} variable
#
# TARGET_SESSION_LOG_FILE()
#   usage: TARGET_SESSION_LOG_FILE [ <target_host> [ <username> ] ]
#   desc: echo-return the target session log file path
#   note: if called without argument, try to use ${SSHKEY_USER} and ${TARGET_HOST} variable
#   note: if called without second argument, try to use ${SSHKEY_USER} variable
#
# USER_SSHKEY_FILE()
#   usage: USER_SSHKEY_FILE [ <user> ]
#   desc: echo-return the path to the user sshkey file
#   note: if called without argument, try to use ${SSHKEY_USER}
#
# DISPLAY_USER_SSHKEY_FILE()
#   usage: DISPLAY_USER_SSHKEY_FILE [ <user> ]
#   desc: echo-return the public sshkey of a user
#   note: if called without argument, try to use ${SSHKEY_USER}
#   note: if called without argument and ${SSHKEY_USER} is not set, display the public sshkey of all users
#
# TARGET_PRIVATE_SSHKEY_FILE()
#   usage: TARGET_PRIVATE_SSHKEY_FILE [ <target_host> ]
#   desc: echo-return the path to the private ssh key of the target host
#   note: if called without argument, try to use ${TARGET_HOST} variable
#
# TARGET_PUBLIC_SSHKEY_FILE()
#   usage: TARGET_PUBLIC_SSHKEY_FILE [ <target_host> ]
#   desc: echo-return the path to the public ssh key of the target host
#   note: if called without argument, try to use ${TARGET_HOST} variable
#
# HAS_ACCESS()
#   usage: HAS_ACCESS [ <username> [ <target_host> ] ]
#   desc: echo-return 'true' if <username> is allowed to access to <target_host>, 'false' otherwise
#   note: if called without argument, try to use ${SSHKEY_USER} and ${TARGET_HOST} variable
#   note: if called without second argument, try to use ${TARGET_HOST} variable
#
# TARGETS_LIST()
#   usage: TARGETS_LIST
#   desc: echo-return the list of target host, separated by '\n'
#
# TARGET_ADD()
#   usage: TARGET_ADD <target_host> [ <target_private_sshkey_file> ]
#   desc: add a target host to sshGate
#   important: need to be root to be able to chown ssh priv key
#
# TARGET_DEL()
#   usage: TARGET_DEL <target_host>
#   desc: delete a target host from sshGate
#
# TARGET_RENAME()
#   usage: TARGET_RENAME <target_host> <new_name>
#   desc: rename a target host and create an alias with the old target name
#
# TARGET_DISPLAY_CONF()
#   usage: TARGET_DISPLAY_CONF [ <target> ]
#   desc: display the configuration file of the <target>
#   note: if <target> is not given, try to use ${TARGET_HOST}
#
# TARGET_SET_CONF()
#   usage: TARGET_SET_CONF <target> <variable> [ <value> ]
#   desc: Set a variable/value pair into the target configuration file
#
# TARGET_GET_CONF()
#   usage: TARGET_GET_CONF [ <target> ] <variable>
#   desc: Get the <variable> value from the <target> configuration file
#   note: if <target> is not given, try to use ${TARGET_HOST}
#
# TARGET_GET_SSH_OPTIONS()
#   usage: TARGET_GET_SSH_OPTIONS [ <target> ]
#   desc: get ssh option for ssh processing to a target host
#   note: use private_TARGET_COMPUTE_OPTIONS() function
#   note: if <target> is not given, try to use ${TARGET_HOST}
#
# TARGET_GET_SCP_OPTIONS()
#   usage: TARGET_GET_SCP_OPTIONS [ <target> ]
#   desc: get ssh option for scp processing to a target host
#   note: use private_TARGET_COMPUTE_OPTIONS() function
#   note: if <target> is not given, try to use ${TARGET_HOST}
#
# TARGET_LIST_SSH_LOGINS()
#  usage: TARGET_LIST_SSH_LOGINS [ <target> ]
#  desc: return ssh login list of a target host
#  note: if <target> is not given, try to use ${TARGET_HOST}
#
# TARGET_ADD_SSH_LOGIN()
#   usage: TARGET_ADD_SSH_LOGIN [ <target> ] <login>
#   desc: add a remote ssh login for the target
#   note: if <target> is not given, try to use ${TARGET_HOST}
#
# TARGET_DEL_SSH_LOGIN()
#   usage: TARGET_DEL_SSH_LOGIN [ <target> ] <login>
#   desc: remove a remote ssh login for the target
#   note: if <target> is not given, try to use ${TARGET_HOST}
#
# TARGET_SSH_USE_DEFAULT_KEY()
#   usage: TARGET_SSH_USE_DEFAULT_KEY <target_host>
#   desc: set ssh default key for a host
#   note: you may have access to the <target_host> with the sshkey of the
#         root account, or with the your sshkey and sshagent forwarding.
#
# TARGET_SSH_INSTALL_ALL_KEYS()
#   usage: TARGET_SSH_INSTALL_ALL_KEYS
#   desc: call TARGET_SSH_INSTALL_KEY on all targets
#   note: you may have access to the <target_host> with the sshkey of the
#         root account, or with the your sshkey and sshagent forwarding.
#
# TARGET_SSH_INSTALL_KEY()
#   usage: TARGET_SSH_INSTALL_KEY <target_host>
#   desc: Try to install the public sshkey on the <target_host>
#   note: you may have access to the <target_host> with the sshkey of the
#         root account, or with the your sshkey and sshagent forwarding.
#
# TARGET_SSH_TEST()
#   usage: TARGET_TEST <target_host>
#   desc: Test to connect to the <target_host>
#
# TARGETS_SSH_TEST_ALL()
#   usage: TARGETS_TEST_ALL
#   desc: Test to connect to all target.
#   important: this take a while to test ssh connection on all target
#
# TARGET_ACCESS_INFO()
#   usage: TARGET_ACCESS_INFO <target_host>
#   desc: list all user access of <target_host>, and how those access are granted
#
# TARGET_LIST_ALIASES()
#   usage: TARGET_LIST_ALIASES [ <target_host> ]
#   desc: list aliases of host(s)
#   note: if called without argument, list aliases of all hosts
#
# TARGET_ADD_ALIAS()
#   usage: TARGET_ADD_ALIAS <target_host> <alias>
#   desc: add an <alias> name to the <target_host>
#
# TARGET_DEL_ALIAS()
#   usage: TARGET_DEL_ALIAS <alias>
#   desc: delete an <alias> name of a target_host
#
# TARGET_REAL()
#   usage: TARGET_REAL [ <target_host> ]
#   desc: echo-return the 'real' <target_host> name if the argument
#         is an alias. Otherwise, echo-return <target_host>
#   note: if called without argument, try to use ${TARGET_HOST} variable
#
# TARGET_ACCESS_LIST_USERS()
#   usage: TARGET_ACCESS_LIST_USERS <target_host>
#   desc: list user who have access to <target_host>
#
# TARGET_ACCESS_ADD_USER()
#   usage: TARGET_ACCESS_ADD_USER <target_host> <user>
#   desc: give access to <target_host> to the <user>
#
# TARGET_ACCESS_DEL_USER()
#   usage: TARGET_ACCESS_DEL_USER <target_host> <user>
#   desc: revoke access to <target_host> for the <user>
#
# TARGET_ACCESS_LIST_USERGROUPS()
#   usage: TARGET_ACCESS_LIST_USERGROUPS <target_host>
#   desc: list users' group which have access to <target_host>
#
# TARGET_ACCESS_ADD_USERGROUP()
#   usage: TARGET_ACCESS_ADD_USERGROUP <target_host> <user_group>
#   desc: give access to <target_host> to the <user_group>, ie to all users in this <user_group>
#
# TARGET_ACCESS_DEL_USERGROUP()
#   usage: TARGET_ACCESS_DEL_USERGROUP <target_host> <user_group>
#   desc: revoke access to <target_host> for the <user_group>, ie to all users in this <user_group>
#
# USERS_LIST()
#   usage: USERS_LIST
#   desc: list all sshGate users, separated by '\n'
#
# USER_ADD()
#   usage: USER_ADD <user> <public_sshkey_file>
#   desc: add a user in the sshGate users list.
#
# USER_DEL()
#   usage: USER_DEL <user>
#   desc: delete a user from the sshGate users list
#
# USER_DISPLAY_CONF()
#   usage: USER_DISPLAY_CONF [ <user> ]
#   desc: display <user> configuration file
#   note: if <user> is not given, try to use ${SSHKEY_USER}
#
# USER_SET_CONF()
#   usage: USER_SET_CONF <user> <variable> [ <value> ]
#   desc: set a variable/value pair into the user configuration
#
# USER_GET_CONF()
#   usage: USER_GET_CONF [ <user> ] <variable>
#   desc: get a variable value from the user configuration
#   note: if <user> is not given, try to use ${SSHKEY_USER}
#
# USER_LIST_USERGROUPS()
#   usage: USER_LIST_USERGROUPS [ <user> ]
#   desc: List all users' group, which the user is in.
#   note: users' group name are separated by \n
#   note: if called without argument, try to use ${SSHKEY_USER} variable
#
# USER_LIST_TARGETS()
#   usage: USER_LIST_TARGETS [ <user> ]
#   desc: List all target host, which the <user> has access on
#   note: target host name are separated by '\n'.
#   note: if called without argument, try to use ${SSHKEY_USER} variable
#
# USER_ACCESS_NOTIFY()
#   usage: USER_ACCESS_NOTIFY <user>
#   desc: Send a mail to the user to notify him about its access
#
# USER_ACCESS_INFO()
#   usage: USER_ACCESS_INFO <user>
#   desc: List all user access, and how those access are granted
#
# USERGROUPS_LIST()
#   usage: USERGROUPS_LIST
#   desc: List all users' group of the sshGate
#   note: users' group name are separated by '\n'
#
# USERGROUP_ADD()
#   usage: USERGROUP_ADD <user_group>
#   desc: Add a user group to sshGate
#
# USERGROUP_DEL()
#   usage: USERGROUP_DEL <user_group>
#   desc: Delete a users' group from sshGate
#
# USERGROUP_LIST_USERS()
#   usage: USERGROUP_LIST_USERS <user_group>
#   desc: List all users who are in the <user_group>
#   note: user names are separated by \n
#
# USERGROUP_ADD_USER()
#   usage: USERGROUP_ADD_USER <user_group> <user>
#   desc: Add <user> into the <user_group>
#
# USERGROUP_DEL_USER()
#   usage: USERGROUP_DEL_USER <user_group> <user>
#   desc: Remove <user> from the <user_group>
#
# USERGROUP_LIST_TARGETS()
#   usage: USERGROUP_LIST_TARGETS <user_group>
#   desc: List all targets who are in the <user_group>
#

# ----------------------------------------------------------------------------
if [ "${__SSHGATE_FUNC__:-}" != 'Loaded' ]; then
  __SSHGATE_FUNC__='Loaded'

  # Try to source sshgate.conf
  # %% __SSHGATE_CONF__ %% <-- WARNING: don't remove. used by install.sh
  if [ -z "${__SSHGATE_CONF__:-}" ]; then
    [ -r "`pwd`/sshgate.conf"   ] && . `pwd`/sshgate.conf
    [ -r "${0%/*}/sshgate.conf" ] && . "${0%/*}/sshgate.conf"
    if [ -z "${__SSHGATE_CONF__:-}" ]; then
      echo "ERROR: Unable to load sshgate.conf"
      exit 1;
    fi
  fi

  # %% __LIB_MESSAGE__ %% <-- WARNING: don't remove. used by install.sh
  # %% __LIB_CONF__ %% <-- WARNING: don't remove. used by install.sh

  ERROR () { echo "ERROR: $*" 1>&2; }
  BAD_ARGUMENTS () { ERROR "Bad arguments"; }

  # usage: private_ACL_FILE_ADD <line> <file>
  private_ACL_FILE_ADD () {
    grep "^$1\$" < "$2" >/dev/null 2>/dev/null
    [ $? -ne 0 ] && echo "$1" >> "$2"
  }

  # usage: private_ACL_FILE_DEL <line> <file>
  private_ACL_FILE_DEL () {
    local random=
    random="${RANDOM}"
    grep -v "^$1\$" < "$2" > "/tmp/file.${random}"
    mv "/tmp/file.${random}" "$2"
  }

  # usage: private_MAIL_APPEND <message>
  private_MAIL_APPEND () {
    [ "${__LIB_MAIL__:-}" = 'Loaded' -a "${SSHGATE_MAIL_SEND:-}" = 'true' ] && MAIL_APPEND "$*"
  }

  HELP () {
    local func=
    [ $# -eq 1 ] && func="$1"

    if [ -z "${func}" ]; then
      # == sed explanation ==
      # 1: :loop label
      # 2: read the next line
      # 3: match line which begin by # and ended with () -> ex: "# USERGROUP_DEL_USER()"
      # 4: if the current line not match, goto :loop
      # 5: the current line match 3:, read the next line and print the usage
      # 6: if not at the end of the file, goto :loop
      help=$( < "${SSHGATE_DIR_BIN}/sshgate.func" \
                sed -n -e \
                ':loop
                 n;
                 s/^# \([^ ].*[(][)]\)$/\1/;
                 T loop;
                 n; s/^# *usage: \(.*\)$/\1/p;
                 $! b loop;' )
      echo "== FILES =="
      echo "${help}" | grep --color=never "_FILE"
      echo
      echo "== USERS =="
      echo "${help}" | grep "^USERS\{0,1\}_" | grep -v "_FILE"
      echo
      echo "== USER GROUPS =="
      echo "${help}" | grep "^USERGROUP" | grep -v "_FILE"
      echo
      echo "== TARGETS =="
      echo "${help}" | grep "^TARGETS\{0,1\}_" | grep -v "_ACCESS" | grep -v "_FILE"
      echo
      echo "== TARGET GROUPS =="
      echo "${help}" | grep "^TARGETGROUP" | grep -v "_ACCESS" | grep -v "_FILE"
      echo
      echo "== ACCESS =="
      echo "${help}" | grep "_ACCESS" | grep -v "_FILE"
      echo
      echo "== others =="
      echo "${help}" | grep -v "_FILE"          \
                     | grep -v "^USERS\{0,1\}_" \
                     | grep -v "^USERGROUP"     \
                     | grep -v "^TARGET"        \
                     | grep -v "^TARGETGROUP"   \
                     | grep -v "_ACCESS"
      echo
    else
      # == sed explanation ==
      # 1: :search_func label
      # 2: read the next line
      # 3: match line which contain ${func} -> ex: "# ${func}()". print it if match
      # 4: if the current line not match, goto :search_func
      # 5: :loop label
      # 6: read the next line
      # 7: match line which don't only contain "#"
      # 8: if the current line match, goto :loop, else end
      < "${SSHGATE_DIR_BIN}/sshgate.func" \
        sed -n -e \
        ":search_func
         n;
         s/^# \\(${func}[(][)]\\)$/\1/p;
         T search_func
         :loop
         n;
         s/^#\\(..*\\)$/\1/p;
         t loop;
        "
    fi
    return 0;
  }

  SSHGATE_ACCOUNT_HOMEDIR() {
    cat /etc/passwd | grep "${SSHGATE_GATE_ACCOUNT}" | cut -d':' -f6
  }

  BUILD_AUTHORIZED_KEYS () {
    local home_dir= authorized_keys2= user_key= real_target=

    home_dir=$( SSHGATE_ACCOUNT_HOMEDIR )
    if [ -z "${home_dir}" ]; then
      ERROR "Can't find home directory of ${SSHGATE_GATE_ACCOUNT} user"
      return 1;
    fi

    authorized_keys2="${home_dir}/.ssh/authorized_keys2"

    [ ! -d "${home_dir}/.ssh/" ] && mkdir "${home_dir}/.ssh"

    # reset the authorized_keys2 file
    echo -n '' > "${authorized_keys2}"

    for user in $( USERS_LIST ); do
      user_key=$( cat ` USER_SSHKEY_FILE "${user}" ` )
      echo "command=\"/bin/sh ${SSHGATE_DIR_BIN}/sshgate.sh ${user}\" ${user_key}" >> "${authorized_keys2}"
    done

    chown "${SSHGATE_GATE_ACCOUNT}" "${authorized_keys2}"
    return 0;
  }

  BUILD_KNOWN_HOSTS () {
    local home_dir=

    home_dir=$( SSHGATE_ACCOUNT_HOMEDIR )
    if [ -z "${home_dir}" ]; then
      ERROR "Can't find home directory of ${SSHGATE_GATE_ACCOUNT} user"
      return 1;
    fi

    echo -n '' > "${home_dir}/.ssh/known_hosts"
    for target in $( TARGETS_LIST ); do
      echo -n "- ${target} ... "
      ADD_TARGET_TO_KNOWN_HOST "${target}" "${home_dir}/.ssh/known_hosts"
      echo 'OK'
      for alias in $( TARGET_LIST_ALIASES "${target}" ); do
        echo -n "  . ${alias} ... "
        ADD_TARGET_TO_KNOWN_HOST "${alias}" "${home_dir}/.ssh/known_hosts"
        echo -n 'OK'
      done
    done

    return 0;
  }

  ADD_TARGET_TO_KNOWN_HOST() {
    local target= target_ip= file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"
    [ $# -eq 2 ] && file="$2"
    [ -z "${file}" ] && file="$(SSHGATE_ACCOUNT_HOMEDIR)/.ssh/known_hosts"

    target_ip=$( host "${target}" | grep 'address' | head -n 1 | sed -e 's/^.* \([^ ]*\)$/\1/' )

    ssh-keyscan -t dsa,rsa "${target}"    >> "${file}" 2>/dev/null
    ssh-keyscan -H -t dsa,rsa "${target}" >> "${file}" 2>/dev/null

    ssh-keyscan -t dsa,rsa "${target_ip}"    >> "${file}" 2>/dev/null
    ssh-keyscan -H -t dsa,rsa "${target_ip}" >> "${file}" 2>/dev/null

    chown "${SSHGATE_GATE_ACCOUNT}" "${file}"
  }

  DELETE_TARGET_FROM_KNOWN_HOST() {
    local target= target_hash= file= tmp_file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"
    [ $# -eq 2 ] && file="$2"
    [ -z "${file}" ] && file="$(SSHGATE_ACCOUNT_HOMEDIR)/.ssh/known_hosts"
    tmp_file="/tmp/file.${RANDOM}"

    ADD_TARGET_TO_KNOWN_HOST "${target}" "${tmp_file}"
    target_hash=$( < "${tmp_file}" grep -v "${target}" | cut -d' ' -f 1)

    grep -v "^${target}"      < "${file}"     > "${tmp_file}"
    grep -v "^${target_hash}" < "${tmp_file}" > "${file}"

    chown "${SSHGATE_GATE_ACCOUNT}" "${file}"

    rm -f "${tmp_file}"
  }


  # the target global log file
  # create the log directory if not exists
  TARGET_LOG_FILE () {
    local target= dir=
    [ $# -eq 0 ] && target="${TARGET_HOST:-}" || target="$1"
    target=$( TARGET_REAL "${target}" )

    if [ -z "${target}" ]; then
      echo ''; return 1;
    fi

    dir="${SSHGATE_DIR_LOG}/${target}"
    [ ! -d "${dir}/" ] && mkdir -p "${dir}/"

    touch "${dir}/global.log"
    echo "${dir}/global.log"
    return 0;
  }

  # the user session log file
  TARGET_SESSION_LOG_FILE () {
    local user= target= f=
    if [ $# -eq 0 ]; then
      target="${TARGET_HOST:-}"
      user="${SSHKEY_USER:-}"
    else
      target="$1"
      [ $# -lt 2 ] && user="${SSHKEY_USER:-}" || user="$2"
    fi
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" -o -z "${user}" ]; then
      echo ''; return 1;
    fi

    f="${SSHGATE_DIR_LOG}/${target}/$(date +%Y%m%d%H%M%S).${user}.$$"
    touch "$f"
    echo "$f"
    return 0;
  }

  USER_SSHKEY_FILE () {
    local user= f=
    [ $# -eq 0 ] && user="${SSHKEY_USER:-}" || user="$1"
    f="${SSHGATE_DIR_USERS}/${user}"
    [ ! -r "$f" -o -z "${user}" ] && f=''
    echo "$f"
  }

  DISPLAY_USER_SSHKEY_FILE () {
    local user= f=
    [ $# -eq 0 ] && user="${SSHKEY_USER:-all}" || user="$1"
    if [ "${user}" != 'all' ]; then
      f=$( USER_SSHKEY_FILE "${user}" )
      if [ -n "$f" ]; then
        echo "# public sshkey ${user}"
        cat "$f";
      else
        ERROR "Unknown user $user" ; return 1;
      fi
    else
      for user in $( USERS_LIST ); do
        echo "# public sshkey ${user}"
        cat $( USER_SSHKEY_FILE "${user}" )
      done
    fi
    return 0;
  }

  TARGET_PRIVATE_SSHKEY_FILE () {
    local target= f=
    [ $# -eq 0 ] && target="${TARGET_HOST:-}" || target="$1"
    f="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PRIVATE_SSHKEY_FILENAME}"
    [ ! -r "$f" -o -z "${target}" ] && f="${SSHGATE_TARGET_DEFAULT_PRIVATE_SSHKEY_FILE}"
    echo "$f"
  }

  TARGET_PUBLIC_SSHKEY_FILE () {
    local target= f=
    [ $# -eq 0 ] && target="${TARGET_HOST:-}" || target="$1"
    f="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PUBLIC_SSHKEY_FILENAME}"
    [ ! -r "$f" -o -z "${target}" ] && f="${SSHGATE_TARGET_DEFAULT_PUBLIC_SSHKEY_FILE}"
    echo "$f"
  }

  HAS_ACCESS() {
    local user= target= login= is_admin= is_restricted=

    if [ $# -eq 0 ]; then
      user="${SSHKEY_USER:-}"
      target="${TARGET_HOST:-}"
      login="${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}"
    else
      user="$1"
      [ $# -lt 2 ] && target="${TARGET_HOST:-}" || target="$2"
      [ $# -lt 3 ] && login="${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" || login="$3"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${user}" -o -z "${target}" ]; then
      echo 'false'; return 1;
    fi

    is_admin=$( USER_GET_CONF "${user}" IS_ADMIN )
    is_restricted=$( USER_GET_CONF "${user}" IS_RESTRICTED )

    if [ "${is_admin}"  = 'true' -o "${is_restricted}" = 'false' ]; then
      echo 'true'; return 0;
    fi

    TARGET_ACCESS_LIST_USERS "${target}" | grep "^${user}$" >/dev/null
    if [ $? -eq 0 ]; then
      echo 'true'; return 0;
    fi
    echo 'false'; return 1;
  }

  TARGETS_LIST () {
    local res= find_opt=
    [ $# -eq 1 ] && find_opt="-iname '$1'"

    res=$( eval "find '${SSHGATE_DIR_TARGETS}' -mindepth 1 -type d ${find_opt} -printf '%P\n'" )
    echo "${res}" | sort -u
    return 0;
  }

  TARGET_ADD () {
    local target= privsshkey= target_privsshkey= target_pubsshkey=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"
    if [ -z "${target}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [    -d "${SSHGATE_DIR_TARGETS}/${target}" \
         -o -L "${SSHGATE_DIR_TARGETS}/${target}" ]; then
      ERROR "Target or Alias '${target}' already exist"; return 1;
    fi
    if [ $# -eq 2 ]; then
      privsshkey="$2"
      if [ ! -r "${privsshkey}" -o -z "${privsshkey}" ]; then
        ERROR "Can't read '${privsshkey}'"; return 1;
      fi
    fi

    # check that the host exists (DNS/IP)
    ping -c 1 "${target}" >/dev/null 2>/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Unable to ping ${target} !"; return 1;
    fi

    target_privsshkey="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PRIVATE_SSHKEY_FILENAME}"
    target_pubsshkey="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PUBLIC_SSHKEY_FILENAME}"

    mkdir -p "${SSHGATE_DIR_TARGETS}/${target}"

    if [ -n "${privsshkey}" ]; then
      cp "${privsshkey}" "${target_privsshkey}"
      chmod 400 "${target_privsshkey}"
      chown "${SSHGATE_GATE_ACCOUNT}" "${target_privsshkey}"

      # try to generate the public key, to check that the key doesn't have passphrase
      ssh-keygen -y -f "${target_privsshkey}" > "${target_pubsshkey}"
      if [ $? -ne 0 ]; then
        rm -rf "${SSHGATE_DIR_TARGETS}/${target}"
        ERROR "Unable to generate public ssh key." ; return 1;
      fi
      chown "${SSHGATE_GATE_ACCOUNT}" "${target_pubsshkey}"
    # else use the default sshpriv key
    fi

    # create empty access files
    touch "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}"
    touch "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}"

    ADD_TARGET_TO_KNOWN_HOST "${target}"
    TARGET_SSH_INSTALL_KEY   "${target}"

    private_MAIL_APPEND "Target ${target} added"

    return 0;
  }

  TARGET_DEL () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1
    fi

    for alias in $( TARGET_LIST_ALIASES "${target}" ); do
      rm -f "${SSHGATE_DIR_TARGETS}/${alias}"
    done

    rm -rf "${SSHGATE_DIR_TARGETS}/${target}"
    DELETE_TARGET_FROM_KNOWN_HOST "${target}"

    private_MAIL_APPEND "Target ${target} removed"

    return 0;
  }

  TARGET_RENAME () {
    local target= new_name= new_target=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target=$( TARGET_REAL "$1" ); new_name="$2"; new_target=$( TARGET_REAL "${new_name}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1;
    fi
    if [ "${target}" != "$1" ]; then
      ERROR "Target name '$1' is an alias of '${target}'"; return 1;
    fi
    if [ -n "${new_target}" ]; then
      ERROR "Target name '${new_name}' already used"; return 1;
    fi

    mv "${SSHGATE_DIR_TARGETS}/${target}" "${SSHGATE_DIR_TARGETS}/${new_name}"
    mv "${SSHGATE_DIR_LOG}/${target}" "${SSHGATE_DIR_LOG}/${new_name}"
    echo "Target renamed : ${target} -> ${new_name}"

    TARGET_ADD_ALIAS "${new_name}" "${target}"
    echo "Target alias '${target}' created"

    ADD_TARGET_TO_KNOWN_HOST "${new_name}"
    private_MAIL_APPEND "Target ${target} renamed to ${new_name}"

    return 0;
  }

  TARGET_DISPLAY_CONF() {
    local target="${TARGET_HOST:-}" file=
    if [ $# -gt 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    [ $# -eq 1 ] && target="$1"
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    if [ ! -f "${file}" ]; then
      NOTICE "Target host '${target}' has no configuration file"
    else
      cat "${file}"
    fi
    return 0
  }

  TARGET_SET_CONF() {
    local target= var= value= file=
    if [ $# -lt 2 -o $# -gt 3 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target="$1"; var="$2"
    [ $# -eq 3 ] && value="$3"

    if [ -z "${target}" -o -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    [ ! -f "${file}" ] && touch "${file}"
    CONF_SAVE --conf-file "${file}" "${var}" "${value}"
    chmod a+r "${file}" # ensure file permissions

    private_MAIL_APPEND "Target '${target}' configuration: ${var} = ${value}"

    return 0;
  }

  TARGET_GET_CONF() {
    local target="${TARGET_HOST:-}" var= file=
    if [ $# -lt 1 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ $# -eq 2 ]; then
      target="$1"; shift;
    fi
    var="$1"
    target=$( TARGET_REAL "${target}" )

    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    if [ -f "${file}" ]; then
      CONF_GET --conf-file "${file}" "${var}"
    fi
    return 0;
  }

  private_TARGET_COMPUTE_OPTIONS() {
    local target="${TARGET_HOST:-}" ssh_options= opt= var= is_flag=

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    shift;

    # option_pair syntax : <ssh option>:<sshGate target conf variable>:<is flag option>
    for option_pair in $@; do
      opt=$(     echo "${option_pair}" | cut -d':' -f1 )
      var=$(     echo "${option_pair}" | cut -d':' -f2 )
      is_flag=$( echo "${option_pair}" | cut -d':' -f3 )

      var=$( TARGET_GET_CONF "${target}" "${var}" )
      [ -n "${var}" ] && continue

      if [ "${is_flag}" = 'true' ]; then
        [ "${var}" = 'true' ] && ssh_options="${ssh_options} ${opt}"
      else
        [ -n "${var}" ] && ssh_options="${ssh_options} ${opt} ${var}"
      fi
    done

    echo "${ssh_options}"
    return 0;

  }

  TARGET_GET_SSH_OPTIONS() {
    local target=
    [ $# -eq 1 ] && target="$1"
    private_TARGET_COMPUTE_OPTIONS "${target}"    \
                                  '-p:SSH_PORT'   \
                                  '-X:SSH_ENABLE_X11:true'
  }

  TARGET_GET_SCP_OPTIONS() {
    local target=
    [ $# -eq 1 ] && target="$1"
    private_TARGET_COMPUTE_OPTIONS "${target}" \
                                  '-p:SCP_PORT'
  }

  TARGET_SSH_LIST_LOGINS() {
    local target="${TARGET_HOST:-}" file=
    [ $? -eq 1 ] && target="$1"

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/ssh_logins.list"
    ( [ -f "${file}" ] && cat "${file}";
      echo "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}"; ) | sort -u
    return 0;
  }

  TARGET_SSH_ADD_LOGIN() {
    local target="${TARGET_HOST:-}" file= login=
    if [ $? -eq 2 ]; then
      target="$1"; shift;
    fi
    login="$1"

    [ "${login}" = "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ] && return 0;

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/ssh_logins.list"
    [ ! -e "${file}" ] && touch "${file}"
    echo "${login}" >> "${file}"
    return 0;
  }

  TARGET_SSH_DEL_LOGIN() {
    local target="${TARGET_HOST:-}" login= file= tmp_file=
    if [ $? -eq 2 ]; then
      target="$1"; shift;
    fi
    login="$2"
    [ "${login}" = "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ] && return 0;

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/ssh_logins.list"
    tmp_file="/tmp/file.${RANDOM}"
    [ ! -e "${file}" ] && return 0;
    grep -v  "^${login}$" < "${file}" > "${tmp_file}"
    mv "${tmp_file}" "${file}"
    return 0;
  }

  TARGET_SSH_USE_DEFAULT_KEY () {
    local target=
    if [ $# -eq 0 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    sshkey_file=$( TARGET_PUBLIC_SSHKEY_FILE "${target}" )
    [ "${sshkey_file}" != "${SSHGATE_TARGET_DEFAULT_PUBLIC_SSHKEY_FILE}" ] && rm -f "${sshkey_file}"

    sshkey_file=$( TARGET_PRIVATE_SSHKEY_FILE "${target}" )
    [ "${sshkey_file}" != "${SSHGATE_TARGET_DEFAULT_PRIVATE_SSHKEY_FILE}" ] && rm -f "${sshkey_file}"

    return 0;
  }

  TARGET_SSH_INSTALL_KEY () {
    local target= sshkey_file= known_hosts_file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    sshkey_file=$( TARGET_PUBLIC_SSHKEY_FILE "${target}" )
    if [ -z "${sshkey_file}" ]; then
      ERROR "Unable to find private ssh key of '${target}'" ; return 1;
    fi

    [ $# -eq 2 ] && known_hosts_file="$2"
    if [ -z "${known_hosts_file}" ]; then
      known_hosts_file="$( SSHGATE_ACCOUNT_HOMEDIR )/.ssh/known_hosts"
      cp "${known_hosts_file}" /tmp
      known_hosts_file="/tmp/known_hosts"
    fi

    cat "${sshkey_file}" \
      | ssh -o "ConnectTimeout 5"                          \
            -o "UserKnownHostsFile ${known_hosts_file}"    \
            "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}@${target}"    \
            "umask 077; test -d .ssh || mkdir .ssh ; cat >> .ssh/authorized_keys" 2>/dev/null
    if [ $? -ne 0 ]; then
      echo "NOTICE: Public ssh key of '${target}' can't be installed on '${target}'. Install it manually"
    fi
    return 0
  }

  TARGET_SSH_INSTALL_ALL_KEYS () {
    echo "= Install sshkey on all targets ="
    for target in $( TARGETS_LIST ); do
      echo -n ".  ${target}  ... "
      TARGET_SSH_INSTALL_KEY "${target}"
      [ $? eq 0 ] && echo 'OK' || echo 'KO'
    done
  }

  TARGET_SSH_TEST () {
    local target= known_hosts_file= sshkey_file= reply=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    [ $# -eq 2 ] && known_hosts_file="$2"

    if [ -z "${known_hosts_file}" ]; then
      known_hosts_file="$( SSHGATE_ACCOUNT_HOMEDIR )/.ssh/known_hosts"
      cp "${known_hosts_file}" /tmp
      known_hosts_file="/tmp/known_hosts"
    fi

    echo -n "-  ${target}  ... "
    sshkey_file=$( TARGET_PRIVATE_SSHKEY_FILE "${target}" )
    ssh_options=$( TARGET_GET_SSH_OPTIONS "${target}" )
    reply=$( ssh -o "ConnectTimeout 5"                       \
                 -o "UserKnownHostsFile ${known_hosts_file}" \
                 -o "BatchMode yes"                          \
                 -o "IdentitiesOnly yes"                     \
                 -i "${sshkey_file}"                         \
                 ${ssh_options}                              \
                 "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}@${target}" "echo 'test'" 2>&1 )
    if [ $? -eq 0 -a "${reply}" = 'test' ]; then
      echo 'OK';
    else
      echo 'KO';
      echo "     ${reply}";
    fi

    [ $# -ne 2 ] && rm -f "${known_hosts_file}"
  }

  TARGET_SSH_TEST_ALL () {
    local known_hosts_file=

    known_hosts_file="$( SSHGATE_ACCOUNT_HOMEDIR )/.ssh/known_hosts"
    cp "${known_hosts_file}" /tmp
    known_hosts_file="/tmp/known_hosts"

    echo "= Test all targets ssh connectivity ="
    for target in $( TARGETS_LIST ); do
      TARGET_SSH_TEST "${target}" "${known_hosts_file}"
    done

    rm -f "${known_hosts_file}"
  }

  TARGET_ACCESS_INFO () {
    local target= targetgroup_list= users_list=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    # direct access
    for user in $( cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}" ); do
      echo "${user} ---> ${target}"
    done

    # access through usergroup
    for usergroup in $( TARGET_ACCESS_LIST_USERGROUPS "${target}" ); do
      users_list=$( USERGROUP_LIST_USERS "${usergroup}" )
      if [ -n "${users_list}" ]; then
        echo -n "${users_list}" | tr $'\n' ','
        echo " --- usergroup(${usergroup}) ---> ${target}"
      fi
    done

    return 0;
  }

  TARGET_LIST_ALIASES () {
    local target= t=
    [ $# -eq 1 ] && target=$( TARGET_REAL "$1" )

    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    for file in $( find "${SSHGATE_DIR_TARGETS}/" -type l ); do
      t=$( readlink -f "${file}" )
      [ -z "${target}" -o "${t##*/}" = "${target}" ] && echo "${file##*/}"
    done | sort -u
    return 0;
  }

  TARGET_ADD_ALIAS () {
    local target=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$(TARGET_REAL "$1"); alias="$2"
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1
    fi
    if [ -z "${alias}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -L "${SSHGATE_DIR_TARGETS}/${alias}" ]; then
      ERROR "Target alias '${alias}' already exists" ; return 1
    fi
    if [ -d "${SSHGATE_DIR_TARGETS}/${alias}" ]; then
      ERROR "Target alias '${alias}' correspond to a target host name" ; return 1
    fi

    ln -s "${SSHGATE_DIR_TARGETS}/${target}" "${SSHGATE_DIR_TARGETS}/${alias}"
    return 0;
  }

  TARGET_DEL_ALIAS () {
    local alias=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    alias="$1"
    if [ -z "${alias}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ ! -L "${alias}" ]; then
      ERROR "Target alias '${alias}' doesn't exist" ; return 1;
    fi

    rm -f "${SSHGATE_DIR_TARGETS}/${alias}"
    return 0;
  }

  TARGET_REAL () {
    local target=
    [ $# -ne 1 ] && target="${TARGET_HOST:-}" || target="$1"

    if [ -z "${target}" ]; then
      echo ''; return 1;
    fi

    if [ -L "${SSHGATE_DIR_TARGETS}/${target}" ]; then
      target=$( readlink -f "${SSHGATE_DIR_TARGETS}/${target}" )
      echo "${target##*/}"
    else
      if [ -d "${SSHGATE_DIR_TARGETS}/${target}" ]; then
        echo "${target}"
      else
        echo ''
        return 1;
      fi
    fi
    return 0;
  }

  TARGET_ACCESS_LIST_USERS () {
    local target= files=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    files="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}"

    # through groups : target -> usergroup -> users
    for usergroup in $( cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}" ); do
      files="${files} ${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"
    done

    cat ${files} | sort -u
    return 0;
  }

  TARGET_ACCESS_ADD_USER () {
    local target= user=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1"); user="$2";
    if [ -z "${user}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_ADD "${user}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}"

    private_MAIL_APPEND "User ${user} access to Target ${target} granted"

    return 0;
  }

  TARGET_ACCESS_DEL_USER () {
    local target= user= access_file= random=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1
    fi

    target=$( TARGET_REAL "$1" ); user="$2"
    if [ -z "${user}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}"

    private_MAIL_APPEND "User ${user} access to Target ${target} revoked"

    return 0;
  }

  TARGET_ACCESS_LIST_USERGROUPS () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}" | sort -u
    return 0;
  }

  TARGET_ACCESS_ADD_USERGROUP () {
    local target= usergroup=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" ); usergroup="$2"
    if [ -z "${usergroup}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_ADD "${usergroup}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}"

    private_MAIL_APPEND "User Group ${usergroup} access to Target ${target} granted"

    return 0;
  }

  TARGET_ACCESS_DEL_USERGROUP () {
    local target= usergroup=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1
    fi

    target=$( TARGET_REAL "$1" ); usergroup="$2"
    if [ -z "${usergroup}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -z "${target}" ]; then
      ERROR "Target  host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_DEL "${usergroup}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}"

    private_MAIL_APPEND "User Group ${usergroup} access to Target ${target} revoked"

    return 0;
  }

  USERS_LIST () {
    ls --color=none -m "${SSHGATE_DIR_USERS}" | tr $'\n' ' ' \
        | sed -e 's/, /,/g' | tr ',' $'\n' | grep -v '.properties$' | sort -u; echo
    return 0;
  }

  USER_ADD () {
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    local user="$1" userkey="$2"
    if [ -z "${user}" -o -z "${userkey}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ ! -r "${userkey}" ]; then
      ERROR "Can't read user ssh key" ; return 1;
    fi
    if [ -z "${user}" -o "${user/ }" != "${user}" ]; then
      ERROR "${user} is not a valid username" ; return 1
    fi

    if [ -f "${SSHGATE_DIR_USERS}/${user}" ]; then
      ERROR "User '${user}' already exists" ; return 1;
    fi

    cp "${userkey}" "${SSHGATE_DIR_USERS}/${user}"
    private_MAIL_APPEND "User ${user} added"

    BUILD_AUTHORIZED_KEYS
    return 0
  }

  USER_DEL () {
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1
    fi

    local user="$1"
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist"  ; return 1;
    fi


    # delete user from groups
    for group in $( USER_LIST_USERGROUPS "${user}" ); do
      private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_USERS_GROUPS}/${group}"
    done

    # delete user from target access list
    for target in $( USER_LIST_TARGETS "${user}" ); do
      private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}"
    done

    rm -f "${SSHGATE_DIR_USERS}/${user}"
    private_MAIL_APPEND "User ${user} removed"

    BUILD_AUTHORIZED_KEYS
    return 0
  }

  USER_DISPLAY_CONF () {
    local user="${SSHKEY_USER:-}" file=
    if [ $# -gt 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi
    [ $# -eq 1 ] && user="$1"

    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist"; return 1;
    fi

    file="${SSHGATE_DIR_USERS}/${user}.properties"
    if [ ! -f "${file}" ]; then
      NOTICE "User '${user}' has no configuration file"
    else
      cat "${file}"
    fi
    return 0
  }

  USER_SET_CONF () {
    local user= var= value= file=
    if [ $# -lt 2 -o $# -gt 3 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    user="$1"; var="$2"
    [ $# -eq 3 ] && value="$3"

    if [ -z "${user}" -o -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist"; return 1;
    fi

    file="${SSHGATE_DIR_USERS}/${user}.properties"
    [ ! -f "${file}" ] && touch "${file}"
    CONF_SAVE --conf-file "${file}" "${var}" "${value}"
    chmod a+r "${file}" # ensure dans file permissions are good

    private_MAIL_APPEND "User '${user}' configuration: ${var} = ${value}"

    return 0;
  }

  USER_GET_CONF () {
    local user="${SSHKEY_USER:-}" var= file=
    if [ $# -lt 1 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ $# -eq 2 ]; then
      user="$1"; shift
    fi
    var="$1"

    if [ -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist"; return 1;
    fi

    file="${SSHGATE_DIR_USERS}/${user}.properties"
    if [ -f "${file}" ]; then
      CONF_GET --conf-file "${file}" "${var}"
      echo "${!var}"
    fi
    return 0
  }

  USER_LIST_USERGROUPS () {
    local user=
    [ $# -eq 0 ] && user="${SSHKEY_USER:-}" || user="$1"

    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    for group in $( grep -l -r "^${user}\$" "${SSHGATE_DIR_USERS_GROUPS}/" | sort -u ); do
      echo "${group##*/}"
    done | sort -u
    return 0;
  }

  USER_LIST_TARGETS () {
    local user= is_restricted=
    [ $# -eq 0 ] && user="${SSHKEY_USER:-}" || user="$1"

    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    is_restricted=$( USER_GET_CONF "${user}" IS_RESTRICTED )
    if [ "${is_restricted}" = 'false' ]; then
      TARGETS_LIST
    else
      ( # subshell :(
          # direct access
          for file in $( find "${SSHGATE_DIR_TARGETS}"                      \
                            -name "${SSHGATE_TARGETS_USER_ACCESS_FILENAME}" \
                            -exec grep -l "^${user}\$" {} \; ); do
            file="${file%%/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}}"
            echo "${file##*/}"
          done

          # access through usergroup
          for usergroup in $( USER_LIST_USERGROUPS "${user}" ); do
            USERGROUP_LIST_TARGETS "${usergroup}"
          done
      ) | sort -u
    fi
    return 0;
  }

  USER_ACCESS_INFO () {
    local user= targets= is_restricted=
    [ $# -eq 0 ] && user="${SSHKEY_USER:-}" || user="$1"

    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    # direct access
    for file in $( find "${SSHGATE_DIR_TARGETS}"                      \
                      -name "${SSHGATE_TARGETS_USER_ACCESS_FILENAME}" \
                      -exec grep -l "^${user}\$" {} \; ); do
      file="${file%%/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}}"
      echo "${user} ---> ${file##*/}"
    done

    # access through usergroup
    for usergroup in $( USER_LIST_USERGROUPS "${user}" ); do
      targets=$( USERGROUP_LIST_TARGETS "${usergroup}" )
      if [ -n "${targets}" ]; then
        echo -n "${user} --- usergroup(${usergroup}) ---> "
        echo -n "${targets}" | tr $'\n' ','; echo
      fi
    done

    is_restricted=$( USER_GET_CONF "${user}" IS_RESTRICTED )
    if [ "${is_restricted}" = 'false' ]; then
      echo "User has access to whole target host, as its configuration IS_RESTRICTED variable is set to 'false'.";
    fi
    return 0;
  }

  USER_ACCESS_NOTIFY () {
    local user= user_mail= mail_file= old_mail_file= aliases=

    [ $# -eq 0 ] && user="${SSHKEY_USER:-}" || user="$1"

    user_mail=$( USER_GET_CONF "${user}" MAIL )
    if [ -z "${user_mail}" ]; then
      ERROR "No e-mail was setup for user '${user}'"; return 1;
    fi

    old_mail_file=$( MAIL_GET_FILE )
    MAIL_CREATE

    MAIL_APPEND "Hi,"
    MAIL_APPEND ''
    MAIL_APPEND "Here is the list of servers you have access to through sshGate :"
    MAIL_APPEND ''
    for target in $( USER_LIST_TARGETS "${user}" ); do
      MAIL_APPEND " - ${target}"
      aliases=
      aliases=$( TARGET_LIST_ALIASES "${target}" )
      if [ "${aliases}" != '' ]; then
        aliases=$( echo "${aliases}" | tr $'\n' ',' )
        MAIL_APPEND "     alias: ${aliases}"
      fi
    done
    MAIL_SEND "Your sshGate access" "${user_mail}"

    MAIL_SET_FILE "${old_mail_file}"
    return 0
  }

  USERGROUPS_LIST () {
    ls --color=none -m "${SSHGATE_DIR_USERS_GROUPS}" | tr $'\n' ' ' | sed -e 's/, /,/g' | tr ',' $'\n' | sort -u; echo
    return 0;
  }

  USERGROUP_ADD () {
    local usergroup=

    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ -z "${usergroup}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" ]; then
      ERROR "User group '${usergroup}' already exists" ; return 1
    fi

    touch "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"

    private_MAIL_APPEND "User Group ${usergroup} added"

    return 0;
  }

  USERGROUP_DEL () {
    local usergroup=

    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1
    fi

    for target in $( USERGROUP_LIST_TARGETS "${usergroup}" ); do
      TARGET_ACCESS_DEL_USERGROUP "${target}" "${usergroup}"
    done

    rm -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"

    private_MAIL_APPEND "User Group ${usergroup} removed"

    return 0
  }

  USERGROUP_LIST_USERS () {
    local usergroup=

    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    cat "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" | sort -u
    return 0;
  }

  USERGROUP_ADD_USER () {
    local usergroup= user=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"; user="$2";
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_ADD "${user}" "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"

    private_MAIL_APPEND "User ${user} added to User Group ${usergroup}"

    return 0;
  }

  USERGROUP_DEL_USER () {
    local usergroup= user=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"; user="$2"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"

    private_MAIL_APPEND "User ${user} removed from User Group ${usergroup}"

    return 0;
  }

  USERGROUP_LIST_TARGETS () {
    local usergroup= target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    for file in $( find "${SSHGATE_DIR_TARGETS}"                           \
                      -name "${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}" \
                      -exec grep -l "^${usergroup}\$" {} \; ); do
      file="${file%%/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}}"
      echo "${file##*/}"
    done | sort -u
    return 0;
  }

fi # __SSHGATE_FUNC__
