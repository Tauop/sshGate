#
# Copyright (c) 2010 Linagora
# Patrick Guiran <pguiran@linagora.com>
# http://github.com/Tauop/sshGate
#
# sshGate is free software, you can redistribute it and/or modify
# it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# sshGate is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# README ---------------------------------------------------------------------
# Collection of all need functions to deal with sshgate administrations.
#
# FUNCTIONS ------------------------------------------------------------------
#
# HELP()
#   usage: HELP [ <function_name> ]
#   desc: if called without argument, display all functions usage list.
#         if called with a function_name, display all information about this function
#
# SSHGATE_ACCOUNT_HOMEDIR()
#   usage: SSHGATE_ACCOUNT_HOMEDIR
#   desc: return the home directory of the SSHGATE_GATE_ACCOUNT user
#
# GET_LOGIN()
#   usage: GET_LOGIN <string>
#   desc: Echo-return the login from a connection string
#   note: if the string doesn't contain the login, we try to get the DEFAULT_SSH_LOGIN
#         of the host, otherwise ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
#
# GET_HOST()
#   usage: GET_HOST <string>
#   desc: Echo-return the host from a connection string
#
# BUILD_AUTHORIZED_KEYS()
#   usage: BUILD_AUTHORIZED_KEYS
#   desc: update the authorized_key2 of the sshGate account
#   important: need to be root to be able to update authorized_keys2 and chown files
#
# BUILD_KNOWN_HOSTS()
#   usage: BUILD_KNOWN_HOSTS
#   desc: update the known_hosts file
#   important: need to be root
#
# ADD_TARGET_TO_KNOWN_HOST()
#   usage: ADD_TARGET_TO_KNOWN_HOST <target> [ <file> ]
#   desc: call ssh-keyscan to the <target> and add the public host sshkey to the <file>
#   note: if <file> is not specified, determine it with SSHGATE_ACCOUNT_HOMEDIR
#
# DELETE_TARGET_FROM_KNOWN_HOST()
#   usage: DELETE_TARGET_FROM_KNOWN_HOST <target> [ <file> ]
#   desc: delete the public host sshkey of the <target> from the known_hosts file
#   note: if <file> is not specified, determine it with SSHGATE_ACCOUNT_HOMEDIR
#
# TARGET_LOG_FILE()
#   usage: TARGET_LOG_FILE <target_host>
#   desc: echo-return the target global log file
#   note: create the target main directory in ${SSHGATGE_DIR_LOG} if needed
#
# TARGET_SESSION_LOG_FILE()
#   usage: TARGET_SESSION_LOG_FILE <target_host> <username>
#   desc: echo-return the target session log file path
#
# USER_SSHKEY_FILE()
#   usage: USER_SSHKEY_FILE <user>
#   desc: echo-return the path to the user sshkey file
#
# DISPLAY_USER_SSHKEY_FILE()
#   usage: DISPLAY_USER_SSHKEY_FILE <user>
#   desc: echo-return the public sshkey of a user
#   note: if called without argument, display the public sshkey of all users
#
# TARGET_PRIVATE_SSHKEY_FILE()
#   usage: TARGET_PRIVATE_SSHKEY_FILE <target_host>
#   desc: echo-return the path to the private ssh key of the target host
#
# TARGET_PUBLIC_SSHKEY_FILE()
#   usage: TARGET_PUBLIC_SSHKEY_FILE <target_host>
#   desc: echo-return the path to the public ssh key of the target host
#
# HAS_ACCESS()
#   usage: HAS_ACCESS <username> [<login>@]<target_host>
#   usage: HAS_ACCESS <username> <target_host> <login>
#   desc: echo-return 'true' if <username> is allowed to access to <target_host>, 'false' otherwise
#   note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
#
# TARGETS_LIST()
#   usage: TARGETS_LIST
#   desc: echo-return the list of target host, separated by '\n'
#
# TARGET_ADD()
#   usage: TARGET_ADD [<login>@]<target_host> [ <target_private_sshkey_file> ]
#   desc: add a target host to sshGate
#   note: it will add the ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN} login to target
#   note: it will try to install public sshket to the target authorized_keys2
#   note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
#   important: need to be root to be able to chown ssh priv key
#
# TARGET_DEL()
#   usage: TARGET_DEL <target_host>
#   desc: delete a target host from sshGate
#
# TARGET_RENAME()
#   usage: TARGET_RENAME <target_host> <new_name>
#   desc: rename a target host and create an alias with the old target name
#
# TARGET_DISPLAY_CONF()
#   usage: TARGET_DISPLAY_CONF <target>
#   desc: display the configuration file of the <target>
#
# TARGET_SET_CONF()
#   usage: TARGET_SET_CONF <target> <variable> [ <value> ]
#   desc: Set a variable/value pair into the target configuration file
#   note: if no <value> is given, the <variable> is removed from the
#         configuration file of the <target>
#
# TARGET_GET_CONF()
#   usage: TARGET_GET_CONF <target> <variable>
#   desc: Get the <variable> value from the <target> configuration file
#
# TARGET_SSH_EDIT_CONFIG()
#   usage: TARGET_SSH_EDIT_CONFIG <target> [ <login> ]
#   usage: TARGET_SSH_EDIT_CONFIG [<login>@<target>]
#   desc: Edit the ssh configuration file of the <target> for <login>
#   note: if <login> is not given, try to use default ssh login of the target
#         host, or the sshGate target's default ssh login
#   note: if <target> is egal to "all", edit the global ssh configuration for
#         "Host *". In this case, we don't care about <login>.
#
# TARGET_SSH_GET_CONFIG()
#   usage: TARGET_SSH_GET_CONFIG <target> [ <login> ]
#   usage: TARGET_SSH_GET_CONFIG [<login>@]<target>
#   desc: Generate and get the filename of a ssh configuration, which can be
#         used to connect to the <target> with <login>
#   note: if <login> is not given, try to use default ssh login of the target
#         host, or the sshGate target's default ssh login
#
# TARGET_SSH_DISPLAY_GLOBAL_CONFIG()
#   usage: TARGET_SSH_DISPLAY_GLOBAL_CONFIG
#   desc: Display global ssh configuration file used, which declare options
#         for "Host *"
#
# TARGET_SSH_DISPLAY_CONFIG()
#   usage: TARGET_SSH_DISPLAY_CONFIG <target> [ <login> ]
#   usage: TARGET_SSH_DISPLAY_CONFIG [<login>@]<target>
#   desc: Display simple ssh configuration file used to connect to <target>
#         with <login>
#   note: if <login> is not given, try to use default ssh login of the target
#         host, or the sshGate target's default ssh login
#
# TARGET_SSH_DISPLAY_FULL_CONFIG()
#   usage: TARGET_SSH_DISPLAY_FULL_CONFIG <target> [ <login> ]
#   usage: TARGET_SSH_DISPLAY_FULL_CONFIG [<login>@]<target>
#   desc: Display full generated ssh configuration file used to connect to
#         <target> with <login>
#   note: if <login> is not given, try to use default ssh login of the target
#         host, or the sshGate target's default ssh login
#
# TARGET_LIST_SSH_LOGINS()
#  usage: TARGET_LIST_SSH_LOGINS <target>
#  desc: return ssh login list of a target host
#
# TARGET_ADD_SSH_LOGIN()
#   usage: TARGET_ADD_SSH_LOGIN <target> <login>
#   desc: add a remote ssh login for the target
#
# TARGET_DEL_SSH_LOGIN()
#   usage: TARGET_DEL_SSH_LOGIN <target> <login>
#   desc: remove a remote ssh login for the target
#
# TARGET_SSH_USE_DEFAULT_KEY()
#   usage: TARGET_SSH_USE_DEFAULT_KEY <target_host>
#   desc: set ssh default key for a host
#   note: you may have access to the <target_host> with the sshkey of the
#         root account, or with the your sshkey and sshagent forwarding.
#
# TARGET_SSH_INSTALL_ALL_KEYS()
#   usage: TARGET_SSH_INSTALL_ALL_KEYS
#   desc: call TARGET_SSH_INSTALL_KEY on all targets
#   note: you may have access to the <target_host> with the sshkey of the
#         root account, or with the your sshkey and sshagent forwarding.
#
# TARGET_SSH_INSTALL_KEY()
#   usage: TARGET_SSH_INSTALL_KEY <target_host> <login>
#   desc: Try to install the public sshkey on the <target_host>
#   note: you may have access to the <target_host> with the sshkey of the
#         root account, or with the your sshkey and sshagent forwarding.
#
# TARGET_SSH_TEST()
#   usage: TARGET_TEST <login>@<target_host>
#   desc: Test to connect to the <target_host>
#
# TARGET_SSH_TEST_ALL()
#   usage: TARGETS_TEST_ALL
#   desc: Test to connect to all target.
#   important: this take a while to test ssh connection on all target
#
# TARGET_ACCESS_INFO()
#   usage: TARGET_ACCESS_INFO <target_host>
#   desc: list all user access of <target_host>, and how those access are
#         granted for each login of the <target_host>
#
# TARGET_LIST_ALIASES()
#   usage: TARGET_LIST_ALIASES [ <target_host> ]
#   desc: list aliases of host(s)
#   note: if called without argument, list aliases of all hosts
#
# TARGET_ADD_ALIAS()
#   usage: TARGET_ADD_ALIAS <target_host> <alias>
#   desc: add an <alias> name to the <target_host>
#
# TARGET_DEL_ALIAS()
#   usage: TARGET_DEL_ALIAS <alias>
#   desc: delete an <alias> name of a target_host
#
# TARGET_REAL()
#   usage: TARGET_REAL <target_host>
#   desc: echo-return the 'real' <target_host> name if the argument
#         is an alias. Otherwise, echo-return <target_host>
#
# TARGET_ACCESS_LIST_USERS()
#   usage: TARGET_ACCESS_LIST_USERS [<login>@]<target_host>
#   usage: TARGET_ACCESS_LIST_USERS <target_host> <login>
#   desc: list users who have access to <login>@<target_host>
#   note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
#
# TARGET_ACCESS_LIST_ALL_USERS()
#  usage: TARGET_ACCESS_LIST_USERS <target_host>
#  desc: List users who have access to <target_host> for each <login>
#
# TARGET_ACCESS_ADD_USER()
#   usage: TARGET_ACCESS_ADD_USER [<login>@]<target_host> <user>
#   usage: TARGET_ACCESS_ADD_USER <target_host> <login> <user>
#   desc: give access to <target_host> to the <user>
#   note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
#
# TARGET_ACCESS_DEL_USER()
#   usage: TARGET_ACCESS_DEL_USER [<login>@]<target_host> <user>
#   usage: TARGET_ACCESS_DEL_USER <target_host> <login> <user>
#   desc: revoke access to <target_host> for the <user>
#   note: if no <login> is given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
#
# TARGET_ACCESS_LIST_USERGROUPS()
#   usage: TARGET_ACCESS_LIST_USERGROUPS [<login>@]<target_host>
#   usage: TARGET_ACCESS_LIST_USERGROUPS <target_host> <login>
#   desc: list users' group which have access to <login>@<target_host>
#
# TARGET_ACCESS_LIST_ALL_USERGROUPS()
#   usage: TARGET_ACCESS_LIST_ALL_USERGROUPS <target_host>
#   desc: list users' group which have access to <target_host> for all
#         login, which exists for <target_host>
#
# TARGET_ACCESS_ADD_USERGROUP()
#   usage: TARGET_ACCESS_ADD_USERGROUP [<login>@]<target_host> <user_group>
#   usage: TARGET_ACCESS_ADD_USERGROUP <target_host> <login> <user_group>
#   desc: give access to <login>@<target_host> to the <user_group>, ie to all
#         users in this <user_group>
#   note: if <login> is not given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
#
# TARGET_ACCESS_DEL_USERGROUP()
#   usage: TARGET_ACCESS_DEL_USERGROUP [<login>@]<target_host> <user_group>
#   usage: TARGET_ACCESS_DEL_USERGROUP <target_host> <login> <user_group>
#   desc: revoke access to <login>@<target_host> for the <user_group>, ie to
#         all users in this <user_group>
#   note: if <login> is not given, use ${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}
#
# USERS_LIST()
#   usage: USERS_LIST
#   desc: list all sshGate users, separated by '\n'
#
# USER_ADD()
#   usage: USER_ADD <user> <public_sshkey_file>
#   desc: add a user in the sshGate users list.
#
# USER_DEL()
#   usage: USER_DEL <user>
#   desc: delete a user from the sshGate users list
#
# USER_DISPLAY_CONF()
#   usage: USER_DISPLAY_CONF <user>
#   desc: display <user> configuration file
#
# USER_SET_CONF()
#   usage: USER_SET_CONF <user> <variable> [ <value> ]
#   desc: set a variable/value pair into the user configuration
#   note: if no <value> is given, the <variable> is removed from the
#         configuration file of the <user>
#
# USER_GET_CONF()
#   usage: USER_GET_CONF <user> <variable>
#   desc: get a variable value from the user configuration
#
# USER_LIST_USERGROUPS()
#   usage: USER_LIST_USERGROUPS <user>
#   desc: List all users' group, which the user is in.
#   note: users' group name are separated by \n
#
# USER_LIST_TARGETS()
#   usage: USER_LIST_TARGETS <user>
#   desc: List all target host, which the <user> has access on
#   note: target host name are separated by '\n'.
#
# USER_ACCESS_NOTIFY()
#   usage: USER_ACCESS_NOTIFY <user>
#   desc: Send a mail to the user to notify him about its access
#
# USER_ACCESS_INFO()
#   usage: USER_ACCESS_INFO <user>
#   desc: List all user access, and how those access are granted
#
# USERGROUPS_LIST()
#   usage: USERGROUPS_LIST
#   desc: List all users' group of the sshGate
#   note: users' group name are separated by '\n'
#
# USERGROUP_ADD()
#   usage: USERGROUP_ADD <user_group>
#   desc: Add a user group to sshGate
#
# USERGROUP_DEL()
#   usage: USERGROUP_DEL <user_group>
#   desc: Delete a users' group from sshGate
#
# USERGROUP_LIST_USERS()
#   usage: USERGROUP_LIST_USERS <user_group>
#   desc: List all users who are in the <user_group>
#   note: user names are separated by \n
#
# USERGROUP_ADD_USER()
#   usage: USERGROUP_ADD_USER <user_group> <user>
#   desc: Add <user> into the <user_group>
#
# USERGROUP_DEL_USER()
#   usage: USERGROUP_DEL_USER <user_group> <user>
#   desc: Remove <user> from the <user_group>
#
# USERGROUP_LIST_TARGETS()
#   usage: USERGROUP_LIST_TARGETS <user_group>
#   desc: List all targets who are in the <user_group>
#
# USERGROUP_ACCESS_INFO()
#   usage: USERGROUP_ACCESS_INFO <user_group>
#   desc: display access information for the <user_group>
#
# USERGROUP_ACCESS_NOTIFY()
#   usage: USERGROUP_ACCESS_NOTIFY <user_group>
#   desc: call USER_ACCESS_NOTIFY on each user of the <user_group>
#
# ----------------------------------------------------------------------------
if [ "${__SSHGATE_FUNC__:-}" != 'Loaded' ]; then
  __SSHGATE_FUNC__='Loaded'

  # Try to source sshgate.conf
  # %% __SSHGATE_CONF__ %% <-- WARNING: don't remove. used by install.sh
  # %% __LIB_RANDOM__ %% <-- WARNING: don't remove. used by install.sh
  # %% __LIB_MESSAGE__ %% <-- WARNING: don't remove. used by install.sh
  # %% __LIB_CONF__ %% <-- WARNING: don't remove. used by install.sh

  ERROR () { echo "ERROR: $*" 1>&2; }
  BAD_ARGUMENTS () { ERROR "Bad arguments"; }

  # usage: private_ACL_FILE_ADD <line> <file>
  private_ACL_FILE_ADD () {
    [ ! -f "$2" ] && touch "$2" # to avoid bugs
    grep "^$1\$" < "$2" >/dev/null 2>/dev/null
    [ $? -ne 0 ] && echo "$1" >> "$2"
  }

  # usage: private_ACL_FILE_DEL <line> <file>
  private_ACL_FILE_DEL () {
    local random=$( RANDOM )
    [ ! -f "$2" ] && return 0; # to avoir bugs
    grep -v "^$1\$" < "$2" > "/tmp/file.${random}"
    mv "/tmp/file.${random}" "$2"
  }

  # usage: private_MAIL_APPEND <message>
  private_MAIL_APPEND () {
    [ "${__LIB_MAIL__:-}" = 'Loaded' -a "${SSHGATE_MAIL_SEND:-}" = 'true' ] && MAIL_APPEND "$*"
  }

  HELP () {
    local func=
    [ $# -eq 1 ] && func="$1"

    if [ -z "${func}" ]; then
      # == sed explanation ==
      # 1: :loop label
      # 2: read the next line
      # 3: match line which begin by # and ended with () -> ex: "# USERGROUP_DEL_USER()"
      # 4: if the current line not match, goto :loop
      # 5: the current line match 3:, read the next line and print the usage
      # 6: if not at the end of the file, goto :loop
      help=$( < "${SSHGATE_DIR_BIN}/sshgate.func" \
                sed -n -e \
                ':loop
                 n;
                 s/^# \([^ ].*[(][)]\)$/\1/;
                 T loop;
                 n; s/^# *usage: \(.*\)$/\1/p;
                 $! b loop;' )
      echo "== FILES =="
      echo "${help}" | grep --color=never "_FILE"
      echo
      echo "== USERS =="
      echo "${help}" | grep "^USERS\{0,1\}_" | grep -v "_FILE"
      echo
      echo "== USER GROUPS =="
      echo "${help}" | grep "^USERGROUP" | grep -v "_FILE"
      echo
      echo "== TARGETS =="
      echo "${help}" | grep "^TARGETS\{0,1\}_" | grep -v "_ACCESS" | grep -v "_FILE"
      echo
      echo "== TARGET GROUPS =="
      echo "${help}" | grep "^TARGETGROUP" | grep -v "_ACCESS" | grep -v "_FILE"
      echo
      echo "== ACCESS =="
      echo "${help}" | grep "_ACCESS" | grep -v "_FILE"
      echo
      echo "== others =="
      echo "${help}" | grep -v "_FILE"          \
                     | grep -v "^USERS\{0,1\}_" \
                     | grep -v "^USERGROUP"     \
                     | grep -v "^TARGET"        \
                     | grep -v "^TARGETGROUP"   \
                     | grep -v "_ACCESS"
      echo
    else
      # == sed explanation ==
      # 1: :search_func label
      # 2: read the next line
      # 3: match line which contain ${func} -> ex: "# ${func}()". print it if match
      # 4: if the current line not match, goto :search_func
      # 5: :loop label
      # 6: read the next line
      # 7: match line which don't only contain "#"
      # 8: if the current line match, goto :loop, else end
      < "${SSHGATE_DIR_BIN}/sshgate.func" \
        sed -n -e \
        ":search_func
         n;
         s/^# \\(${func}[(][)]\\)$/\1/p;
         T search_func
         :loop
         n;
         s/^#\\(..*\\)$/\1/p;
         t loop;
        "
    fi
    return 0;
  }

  SSHGATE_ACCOUNT_HOMEDIR() {
    cat /etc/passwd | grep "^${SSHGATE_GATE_ACCOUNT}:" | cut -d':' -f6
  }

  GET_LOGIN () {
    local string="$1" login=

    # the login is present in the connection string
    if [ "${string}" != "${string%%@*}" ]; then
      echo "${string%%@*}";
      return 0;
    fi

    login=$( TARGET_GET_CONF "${string}" DEFAULT_SSH_LOGIN )
    if [ -n "${login}" ]; then
      echo "${login}"
    else
      echo "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}"
    fi
    return 0;
  }

  GET_HOST () { echo "${1#*@}"; return 0; }

  BUILD_AUTHORIZED_KEYS () {
    local home_dir= authorized_keys2= user_key= real_target=

    home_dir=$( SSHGATE_ACCOUNT_HOMEDIR )
    if [ -z "${home_dir}" ]; then
      ERROR "Can't find home directory of ${SSHGATE_GATE_ACCOUNT} user"
      return 1;
    fi

    authorized_keys2="${home_dir}/.ssh/authorized_keys2"

    [ ! -d "${home_dir}/.ssh/" ] && mkdir "${home_dir}/.ssh"

    # reset the authorized_keys2 file
    echo -n '' > "${authorized_keys2}"

    for user in $( USERS_LIST ); do
      user_key=$( cat ` USER_SSHKEY_FILE "${user}" ` )
      echo "command=\"/bin/sh ${SSHGATE_DIR_BIN}/sshgate.sh ${user}\" ${user_key}" >> "${authorized_keys2}"
    done

    chown "${SSHGATE_GATE_ACCOUNT}" "${authorized_keys2}"
    chmod u+r "${authorized_keys2}"
    return 0;
  }

  BUILD_KNOWN_HOSTS () {
    local home_dir= target= alias=
    home_dir=$( SSHGATE_ACCOUNT_HOMEDIR )
    if [ -z "${home_dir}" ]; then
      ERROR "Can't find home directory of ${SSHGATE_GATE_ACCOUNT} user"
      return 1;
    fi

    echo -n '' > "${home_dir}/.ssh/known_hosts"
    for target in $( TARGETS_LIST ); do
      target=$( GET_HOST "${target}" )
      echo -n "- ${target} ... "
      ADD_TARGET_TO_KNOWN_HOST "${target}" "${home_dir}/.ssh/known_hosts"
      echo 'OK'
      for alias in $( TARGET_LIST_ALIASES "${target}" ); do
        echo -n "  . ${alias} ... "
        ADD_TARGET_TO_KNOWN_HOST "${alias}" "${home_dir}/.ssh/known_hosts"
        echo 'OK'
      done
    done

    return 0;
  }

  ADD_TARGET_TO_KNOWN_HOST() {
    local target= target_ip= file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"
    [ $# -eq 2 ] && file="$2"
    [ -z "${file}"   ] && file="$(SSHGATE_ACCOUNT_HOMEDIR)/.ssh/known_hosts"
    [ ! -f "${file}" ] && touch "${file}"
    target_ip=$( host "${target}" | grep 'address' | head -n 1 | sed -e 's/^.* \([^ ]*\)$/\1/' )

    ssh-keyscan -t dsa,rsa "${target}"    >> "${file}" 2>/dev/null
    ssh-keyscan -H -t dsa,rsa "${target}" >> "${file}" 2>/dev/null

    ssh-keyscan -t dsa,rsa "${target_ip}"    >> "${file}" 2>/dev/null
    ssh-keyscan -H -t dsa,rsa "${target_ip}" >> "${file}" 2>/dev/null

    chown "${SSHGATE_GATE_ACCOUNT}" "${file}"
  }

  DELETE_TARGET_FROM_KNOWN_HOST() {
    local target= target_hash= file= tmp_file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"
    [ $# -eq 2 ] && file="$2"
    [ -z "${file}" ] && file="$(SSHGATE_ACCOUNT_HOMEDIR)/.ssh/known_hosts"
    tmp_file="/tmp/file.$( RANDOM )"

    ADD_TARGET_TO_KNOWN_HOST "${target}" "${tmp_file}"
    target_hash=$( < "${tmp_file}" grep -v "${target}" | cut -d' ' -f 1)

    grep -v "^${target}"      < "${file}"     > "${tmp_file}"
    grep -v "^${target_hash}" < "${tmp_file}" > "${file}"

    chown "${SSHGATE_GATE_ACCOUNT}" "${file}"

    rm -f "${tmp_file}"
  }


  # the target global log file
  # create the log directory if not exists
  TARGET_LOG_FILE () {
    local target= dir=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      echo ''; return 1;
    fi

    dir="${SSHGATE_DIR_LOG}/${target}"
    [ ! -d "${dir}/" ] && mkdir -p "${dir}/"

    touch "${dir}/global.log"
    echo "${dir}/global.log"
    return 0;
  }

  # the user session log file
  TARGET_SESSION_LOG_FILE () {
    local user= target= f=

    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; user="$2"
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" -o -z "${user}" ]; then
      echo ''; return 1;
    fi

    f="${SSHGATE_DIR_LOG}/${target}/$(date +%Y%m%d%H%M%S).${user}.$$"
    touch "$f"
    echo "$f"
    return 0;
  }

  USER_SSHKEY_FILE () {
    local user= f=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    user="$1"
    f="${SSHGATE_DIR_USERS}/${user}"
    [ ! -r "$f" -o -z "${user}" ] && f=''
    echo "$f"
    return 0;
  }

  DISPLAY_USER_SSHKEY_FILE () {
    local user= f=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    user="$1"
    if [ "${user}" != 'all' ]; then
      f=$( USER_SSHKEY_FILE "${user}" )
      if [ -n "$f" ]; then
        echo "# public sshkey ${user}"
        cat "$f";
      else
        ERROR "Unknown user $user" ; return 1;
      fi
    else
      for user in $( USERS_LIST ); do
        echo "# public sshkey ${user}"
        cat $( USER_SSHKEY_FILE "${user}" )
      done
    fi
    return 0;
  }

  TARGET_PRIVATE_SSHKEY_FILE () {
    local target= f=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target="$1"
    f="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PRIVATE_SSHKEY_FILENAME}"
    [ ! -r "$f" -o -z "${target}" ] && f="${SSHGATE_TARGET_DEFAULT_PRIVATE_SSHKEY_FILE}"
    echo "$f"
  }

  TARGET_PUBLIC_SSHKEY_FILE () {
    local target= f=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target="$1"
    f="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PUBLIC_SSHKEY_FILENAME}"
    [ ! -r "$f" -o -z "${target}" ] && f="${SSHGATE_TARGET_DEFAULT_PUBLIC_SSHKEY_FILE}"
    echo "$f"
  }

  HAS_ACCESS() {
    local user= target= login= is_admin= is_restricted=

    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 2 ]; then
      user="$1"
      target=$( GET_HOST "$2" )
      login=$( GET_LOGIN "$2" )
    else
      user="$1"; target="$2"; login="$3"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${user}" -o -z "${target}" ]; then
      echo 'false'; return 1;
    fi

    is_admin=$( USER_GET_CONF "${user}" IS_ADMIN )
    is_restricted=$( USER_GET_CONF "${user}" IS_RESTRICTED )

    if [ "${is_admin}"  = 'true' -o "${is_restricted}" = 'false' ]; then
      TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
      if [ $? -eq 0 ]; then
        echo 'true'; return 0;
      else
        echo 'false'; return 1;
      fi
    fi

    TARGET_ACCESS_LIST_USERS "${target}" "${login}" | grep "^${user}$" >/dev/null
    if [ $? -eq 0 ]; then
      echo 'true'; return 0;
    fi
    echo 'false'; return 1;
  }

  TARGETS_LIST () {
    local res= find_opt=
    [ $# -eq 1 ] && find_opt="-iname '$1'"

    res=$( eval "find '${SSHGATE_DIR_TARGETS}' -mindepth 1 -type d ${find_opt} -printf '%P\n'" )
    echo "${res}" | sort -u
    return 0;
  }

  TARGET_ADD () {
    local target= privsshkey= target_privsshkey= target_pubsshkey=
    if [ $# -ne 1 -a $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( GET_HOST "$1" )
    login=$( GET_LOGIN "$1" )
    if [ -z "${target}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [    -d "${SSHGATE_DIR_TARGETS}/${target}" \
         -o -L "${SSHGATE_DIR_TARGETS}/${target}" ]; then
      ERROR "Target or Alias '${target}' already exist"; return 1;
    fi
    if [ $# -eq 2 ]; then
      privsshkey="$2"
      if [ ! -r "${privsshkey}" -o -z "${privsshkey}" ]; then
        ERROR "Can't read '${privsshkey}'"; return 1;
      fi
    fi

    # check that the host exists (DNS/IP)
    ping -c 1 "${target}" >/dev/null 2>/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Unable to ping ${target} !"; return 1;
    fi

    target_privsshkey="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PRIVATE_SSHKEY_FILENAME}"
    target_pubsshkey="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGET_PUBLIC_SSHKEY_FILENAME}"

    mkdir -p "${SSHGATE_DIR_TARGETS}/${target}"

    if [ -n "${privsshkey}" ]; then
      cp "${privsshkey}" "${target_privsshkey}"
      chmod 400 "${target_privsshkey}"
      chown "${SSHGATE_GATE_ACCOUNT}" "${target_privsshkey}"

      # try to generate the public key, to check that the key doesn't have passphrase
      ssh-keygen -y -f "${target_privsshkey}" > "${target_pubsshkey}"
      if [ $? -ne 0 ]; then
        rm -rf "${SSHGATE_DIR_TARGETS}/${target}"
        ERROR "Unable to generate public ssh key." ; return 1;
      fi
      chown "${SSHGATE_GATE_ACCOUNT}" "${target_pubsshkey}"
    # else use the default sshpriv key
    fi

    TARGET_SSH_ADD_LOGIN "${target}" "${login}"
    ADD_TARGET_TO_KNOWN_HOST "${target}"
    TARGET_SSH_INSTALL_KEY "${target}" "${login}"

    private_MAIL_APPEND "Target ${login}@${target} added"

    return 0;
  }

  TARGET_DEL () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1
    fi

    for alias in $( TARGET_LIST_ALIASES "${target}" ); do
      rm -f "${SSHGATE_DIR_TARGETS}/${alias}"
    done

    rm -rf "${SSHGATE_DIR_TARGETS}/${target}"
    DELETE_TARGET_FROM_KNOWN_HOST "${target}"

    private_MAIL_APPEND "Target ${target} removed"

    return 0;
  }

  TARGET_RENAME () {
    local target= new_name= new_target=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target=$( TARGET_REAL "$1" ); new_name="$2"; new_target=$( TARGET_REAL "${new_name}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1;
    fi
    if [ "${target}" != "$1" ]; then
      ERROR "Target name '$1' is an alias of '${target}'"; return 1;
    fi
    if [ -n "${new_target}" ]; then
      ERROR "Target name '${new_name}' already used"; return 1;
    fi

    mv "${SSHGATE_DIR_TARGETS}/${target}" "${SSHGATE_DIR_TARGETS}/${new_name}"
    [ -d "${SSHGATE_DIR_LOG}/${target}/" ] && mv "${SSHGATE_DIR_LOG}/${target}" "${SSHGATE_DIR_LOG}/${new_name}"
    echo "Target renamed : ${target} -> ${new_name}"

    TARGET_ADD_ALIAS "${new_name}" "${target}"
    echo "Target alias '${target}' created"

    ADD_TARGET_TO_KNOWN_HOST "${new_name}"
    private_MAIL_APPEND "Target ${target} renamed to ${new_name}"

    return 0;
  }

  TARGET_DISPLAY_CONF () {
    local target= file=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    if [ ! -f "${file}" ]; then
      NOTICE "Target host '${target}' has no configuration file"
    else
      cat "${file}"
    fi
    return 0
  }

  TARGET_SET_CONF () {
    local target= var= value= file=
    if [ $# -lt 2 -o $# -gt 3 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target="$1"; var="$2"
    [ $# -eq 3 ] && value="$3"

    if [ -z "${target}" -o -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    if [ -n "${value}" ]; then
      [ ! -f "${file}" ] && touch "${file}"
      CONF_SAVE --conf-file "${file}" "${var}" "${value}"
      private_MAIL_APPEND "Target '${target}' configuration: ${var} = ${value}"
    else
      CONF_DEL --conf-file "${file}" "${var}"
      private_MAIL_APPEND "Target '${target}' configuration: ${var} removed"
    fi

    [ -f "${file}" ] && chmod a+r "${file}" # ensure file permissions
    return 0;
  }

  TARGET_GET_CONF () {
    local target= var= file=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; var="$2"
    target=$( TARGET_REAL "${target}" )

    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/properties"
    if [ -f "${file}" ]; then
      CONF_GET --conf-file "${file}" "${var}"
      eval "echo \"\${${var}}\""
    fi
    return 0;
  }

  private_TARGET_SSH_GET_CONFIG_FILE () {
    local target= login= file=

    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; login="$2"
    file="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.${login}"

    [ ! -f "${file}" ] && touch "${file}"
    echo "${file}"
    return 0;
  }

  TARGET_SSH_EDIT_CONFIG () {
    local target= login= file= tmpfile= bckfile=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ "$1" != 'all' ]; then
      if [ $# -eq 1 ]; then
        target=$( GET_HOST "$1" )
        login=$( GET_LOGIN "$1" )
      else
        target="$1"; login="$2"
      fi

      target=$( TARGET_REAL "${target}" )
      if [ -z "${target}" ]; then
        ERROR "Target host '${target} doesn't exist"; return 1;
      fi

      [ -z "${login}" ] && login=$( GET_LOGIN "${target}" )
      if [ "${login}" != "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ]; then
        # check that the login exist for the target host
        TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}\$" >/dev/null
        if [ $? -ne 0 ]; then
          ERROR "Login '${login}' doesn't exist for the target host '${target}'"
          return 1;
        fi
      fi

      file=$( private_TARGET_SSH_GET_CONFIG_FILE "${target}" "${login}" )
    else
      file="${SSHGATE_DIR_CONF}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.all"
    fi # end of : if [ "${target}" != 'all' ]; then

    [ ! -f "${file}" ] && touch "${file}"

    # backup configuration
    bckfile="${file}.bak"
    cp "${file}" "${bckfile}"

    # edit the file
    eval "${SSHGATE_EDITOR} '${file}'"

    tmpfile="/tmp/ssh_config.${login}.$( RANDOM )"

    # filter out some options and warn if they are used
    for opt in 'BatchMode'                \
               'CheckHostIP'              \
               'ControlMaster'            \
               'ControlPath'              \
               'ForwardAgent'             \
               'IdentityFile'             \
               'PreferredAuthentications' \
               'ProxyCommand'             \
               'StrictHostKeyChecking'    \
               'User'                     \
               'UserKnownHostsFile' ; do
      grep "^[[:space:]]*${opt}[[:space:]]" < "${file}" >/dev/null
      if [ $? -eq 0 ]; then
        echo "WARNING: ssh options '${opt}' was removed from editable configuration file. It's not allowed or deal by sshGate"
        grep -v "^[[:space:]]*${opt}[[:space:]]" < "${file}" > "${tmpfile}"
        mv "${tmpfile}" "${file}"
      fi
    done

    rm -f "${tmpfile}"

    # permissions
    chown "${SSHGATE_GATE_ACCOUNT}" "${file}"
    chmod ug+r "${file}"

    return 0;
  }

  TARGET_SSH_GET_CONFIG () {
    local target= login= proxy= proxy_host= proxy_login= file= tmpfile= known_hosts_file= sshkey_file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target} doesn't exist"; return 1;
    fi

    [ -z "${login}" ] && login=$( GET_LOGIN "${target}" )
    if [ "${login}" != "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ]; then
      # check that the login exist for the target host
      TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}\$" >/dev/null
      if [ $? -ne 0 ]; then
        ERROR "Login '${login}' doesn't exist for the target host '${target}'"
        return 1;
      fi
    fi

    file=$( private_TARGET_SSH_GET_CONFIG_FILE "${target}" "${login}" )
    known_hosts_file="$( SSHGATE_ACCOUNT_HOMEDIR )/.ssh/known_hosts"
    sshkey_file=$( TARGET_PRIVATE_SSHKEY_FILE "${target}" )
    tmpfile="/tmp/ssh_config.$( RANDOM )"

    proxy=$( TARGET_GET_CONF "${target}" SSH_PROXY )
    if [ -n "${proxy}" ]; then
      proxy_host=$( GET_HOST "${proxy}" )
      proxy_host=$( TARGET_REAL "${proxy_host}" )
      proxy_login=$( GET_LOGIN "${proxy}" )
      if [ -z "${proxy_host}" ]; then
        ERROR "Target '${target}' was declared to need proxy target '${proxy_host}' whereas '${proxy_host}' doesn't exist";
        return 1;
      else
        tmpfile=$( TARGET_SSH_GET_CONFIG "${proxy_host}" "${proxy_login}" )
      fi
    else
      # no proxy, but have to get the global ssh configuration
      echo "Host *"                                                      >> "${tmpfile}"
      echo " IdentityFile ${SSHGATE_TARGET_DEFAULT_PRIVATE_SSHKEY_FILE}" >> "${tmpfile}"
      echo " IdentitiesOnly yes"                                         >> "${tmpfile}"
      echo " UserKnownHostsFile ${known_hosts_file}"                     >> "${tmpfile}"
      if [ -r "${SSHGATE_DIR_CONF}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.all" ]; then
        cat "${SSHGATE_DIR_CONF}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.all" >> "${tmpfile}"
      fi
    fi # end of : if [ -n "${proxy}" ]; then

    echo                                           >> "${tmpfile}"
    echo "Host ${target}"                          >> "${tmpfile}"
    echo " IdentityFile ${sshkey_file}"            >> "${tmpfile}"
    echo " IdentitiesOnly yes"                     >> "${tmpfile}"
    echo " User ${login}"                          >> "${tmpfile}"
    if [ -n "${proxy}" ]; then
      echo " ProxyCommand ssh -F ${tmpfile} ${proxy} nc %h %p" >> "${tmpfile}"
    fi
    cat "${file}"                                            >> "${tmpfile}"

    echo "${tmpfile}"
    return 0;
  }

  TARGET_SSH_DISPLAY_GLOBAL_CONFIG () {
    local file="${SSHGATE_DIR_CONF}/${SSHGATE_TARGETS_SSH_CONFIG_FILENAME}.all"
    [ -f "${file}" ] && cat "${file}"
    return 0;
  }

  TARGET_SSH_DISPLAY_CONFIG () {
    local target= login= file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" );
      login=$( GET_LOGIN "$1" );
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target} doesn't exist"; return 1;
    fi

    [ -z "${login}" ] && login=$( GET_LOGIN "${target}" )
    if [ "${login}" != "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ]; then
      # check that the login exist for the target host
      TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}\$" >/dev/null
      if [ $? -ne 0 ]; then
        ERROR "Login '${login}' doesn't exist for the target host '${target}'"
        return 1;
      fi
    fi

    file=$( private_TARGET_SSH_GET_CONFIG_FILE "${target}" "${login}" )
    cat "${file}"
    return 0;
  }

  TARGET_SSH_DISPLAY_FULL_CONFIG () {
    local target= login= file=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target} doesn't exist"; return 1;
    fi

    [ -z "${login}" ] && login=$( GET_LOGIN "${target}" )
    if [ "${login}" != "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ]; then
      # check that the login exist for the target host
      TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}\$" >/dev/null
      if [ $? -ne 0 ]; then
        ERROR "Login '${login}' doesn't exist for the target host '${target}'"
        return 1;
      fi
    fi

    file=$( TARGET_SSH_GET_CONFIG "${target}" "${login}" )
    # sed is needed to remove reference of the temporary generated file
    cat "${file}" | sed -e "s|${file}|ssh_conf_file|g";
    rm -f "${file}"
    return 0;
  }

  TARGET_SSH_LIST_LOGINS () {
    local target= file=
    if [ $# -ne 1 ]; then
     BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_SSH_LOGINS_FILENAME}"
    ( [ -f "${file}" ] && cat "${file}";
      TARGET_GET_CONF "${target}" DEFAULT_SSH_LOGIN;
      echo "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}"; ) | grep -v '^$' | sort -u
    return 0;
  }

  TARGET_SSH_ADD_LOGIN () {
    local target= file= login=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; login="$2"
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_SSH_LOGINS_FILENAME}"
    if [ ! -f "${file}" ]; then
      touch "${file}"
    else
      grep "^${login}$" < "${file}" >/dev/null
      if [ $? -eq 0 ]; then
        ERROR "Login '${login}' already exists for target '${target}'"; return 1;
      fi
    fi # end of : if [ ! -f "${file}" ]; then

    echo "${login}" >> "${file}"
    # create empty access files
    touch "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    touch "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}"

    return 0;
  }

  TARGET_SSH_DEL_LOGIN () {
    local target= login= file= tmp_file=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"; login="$2"
    [ "${login}" = "${SSHGATE_TARGETS_DEFAULT_SSH_LOGIN}" ] && return 0;

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    file="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_SSH_LOGINS_FILENAME}"
    tmp_file="/tmp/file.$( RANDOM )"

    [ ! -e "${file}" ] && return 0;
    grep -v  "^${login}$" < "${file}" > "${tmp_file}"
    mv "${tmp_file}" "${file}"

    # delete access files
    rm -f "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    rm -f "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}"

    return 0;
  }

  TARGET_SSH_USE_DEFAULT_KEY () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    sshkey_file=$( TARGET_PUBLIC_SSHKEY_FILE "${target}" )
    [ "${sshkey_file}" != "${SSHGATE_TARGET_DEFAULT_PUBLIC_SSHKEY_FILE}" ] && rm -f "${sshkey_file}"

    sshkey_file=$( TARGET_PRIVATE_SSHKEY_FILE "${target}" )
    [ "${sshkey_file}" != "${SSHGATE_TARGET_DEFAULT_PRIVATE_SSHKEY_FILE}" ] && rm -f "${sshkey_file}"

    return 0;
  }

  TARGET_SSH_INSTALL_KEY () {
    local target= login= sshkey_file= ssh_conf_file=
    if [ $# -ne 1 -a $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    sshkey_file=$( TARGET_PUBLIC_SSHKEY_FILE "${target}" )
    if [ -z "${sshkey_file}" ]; then
      ERROR "Unable to find private ssh key of '${target}'" ; return 1;
    fi

    ssh_conf_file=$( TARGET_SSH_GET_CONFIG "${target}" "${login}" )

    cat "${sshkey_file}" \
      | ssh -o "ConnectTimeout 5"                          \
            -F "${ssh_conf_file}"                          \
            "${login}@${target}"                           \
            "umask 077; test -d .ssh || mkdir .ssh ; cat >> .ssh/authorized_keys" 2>/dev/null
    if [ $? -ne 0 ]; then
      echo "NOTICE: Public ssh key of '${target}' can't be installed on '${login}@${target}'. Install it manually"
    fi

    rm -f "${ssh_conf_file}"
    return 0
  }

  TARGET_SSH_INSTALL_ALL_KEYS () {
    echo "= Install sshkey on all targets ="
    for target in $( TARGETS_LIST ); do
      for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
        echo -n ".  ${login}@${target}  ... "
        TARGET_SSH_INSTALL_KEY "${login}@${target}"
        [ $? eq 0 ] && echo 'OK' || echo 'KO'
      done
    done
    return 0;
  }

  TARGET_SSH_TEST () {
    local target= login= ssh_conf_file= sshkey_file= reply=
    if [ $# -eq 0 -o $# -gt 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( GET_HOST "$1" )
    login=$( GET_LOGIN "$1" )
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    echo -n "-  ${login}@${target}  ... "
    ssh_conf_file=$( TARGET_SSH_GET_CONFIG "${target}" "${login}" )
    reply=$( ssh -o "ConnectTimeout 5"                       \
                 -o "BatchMode yes"                          \
                 -F "${ssh_conf_file}"                       \
                 "${login}@${target}" "echo 'test'" 2>&1 )
    if [ $? -eq 0 -a "${reply}" = 'test' ]; then
      echo 'OK';
    else
      echo 'KO';
      echo "     ${reply}" | sed -e $'s/\r//';
    fi

    rm -f "${ssh_conf_file}"
    return 0;
  }

  TARGET_SSH_TEST_ALL () {
    echo "= Test all targets ssh connectivity ="
    for target in $( TARGETS_LIST ); do
      for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
        TARGET_SSH_TEST "${login}@${target}"
      done
    done
  }

  TARGET_ACCESS_INFO () {
    local target= login= targetgroup_list= users_list=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    # direct access
    for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
      users_list=$( cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}" | sort -u )
      if [ -n "${users_list}" ]; then
        echo -n "  ${users_list}" | tr $'\n' ','
        echo " ---> ${login}@${target}"
      fi
    done

    # access through usergroup
    for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
      for usergroup in $( TARGET_ACCESS_LIST_USERGROUPS "${target}" "${login}" ); do
        users_list=$( USERGROUP_LIST_USERS "${usergroup}" )
        if [ -n "${users_list}" ]; then
          echo -n "  ${users_list}" | tr $'\n' ','
          echo " --- usergroup(${usergroup}) ---> ${login}@${target}"
        fi
      done
    done # end of : for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
    return 0;
  }

  TARGET_LIST_ALIASES () {
    local target= t=
    if [ $# -eq 1 ]; then
      target=$( TARGET_REAL "$1" )
      if [ -z "${target}" ]; then
        ERROR "Target host '${target}' doesn't exist" ; return 1;
      fi
    fi

    for file in $( find "${SSHGATE_DIR_TARGETS}/" -type l ); do
      t=$( readlink -f "${file}" )
      [ -z "${target}" -o "${t##*/}" = "${target}" ] && echo "${file##*/}"
    done | sort -u
    return 0;
  }

  TARGET_ADD_ALIAS () {
    local target=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "$1" ); alias="$2"
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1
    fi
    if [ -z "${alias}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -L "${SSHGATE_DIR_TARGETS}/${alias}" ]; then
      ERROR "Target alias '${alias}' already exists" ; return 1
    fi
    if [ -d "${SSHGATE_DIR_TARGETS}/${alias}" ]; then
      ERROR "Target alias '${alias}' correspond to a target host name" ; return 1
    fi

    ln -s "${SSHGATE_DIR_TARGETS}/${target}" "${SSHGATE_DIR_TARGETS}/${alias}"
    return 0;
  }

  TARGET_DEL_ALIAS () {
    local alias=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    alias="$1"
    if [ -z "${alias}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ ! -L "${SSHGATE_DIR_TARGETS}/${alias}" ]; then
      ERROR "Target alias '${alias}' doesn't exist" ; return 1;
    fi

    rm -f "${SSHGATE_DIR_TARGETS}/${alias}"
    return 0;
  }

  TARGET_REAL () {
    local target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target="$1"
    if [ -z "${target}" ]; then
      echo ''; return 1;
    fi

    if [ -L "${SSHGATE_DIR_TARGETS}/${target}" ]; then
      target=$( readlink -f "${SSHGATE_DIR_TARGETS}/${target}" )
      echo "${target##*/}"
    else
      if [ -d "${SSHGATE_DIR_TARGETS}/${target}" ]; then
        echo "${target}"
      else
        echo ''
        return 1;
      fi
    fi
    return 0;
  }

  TARGET_ACCESS_LIST_USERS () {
    local target= login= files=
    if [ $# -ne 1 -a $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Login '${login}' doesn't exist on target '${target}'"; return 1;
    fi

    files="${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"

    # through groups : target -> usergroup -> users
    for usergroup in $( cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}" ); do
      files="${files} ${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"
    done

    cat ${files} | sort -u
    return 0;
  }

  TARGET_ACCESS_LIST_ALL_USERS () {
    local target= login=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1;
    fi

    for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
      echo "= ${login}@${target} ="
      TARGET_ACCESS_LIST_USERS "${target}" "${login}"
    done
    return 0;
  }

  TARGET_ACCESS_ADD_USER () {
    local target= login= user=
    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 2 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
      user="$2"
    else
      target="$1"; login="$2"; user="$3"
    fi

    if [ -z "${user}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Login '${login}' doesn't exist on '${target}'"; return 1;
    fi

    private_ACL_FILE_ADD "${user}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    private_MAIL_APPEND "User ${user} access to Target ${login}@${target} granted"

    return 0;
  }

  TARGET_ACCESS_DEL_USER () {
    local target= login= user= access_file=
    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1
    fi

    if [ $# -eq 2 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
      user="$2"
    else
      target="$1"; login="$2"; user="$3"
    fi

    if [ -z "${user}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Login '${login}' doesn't exist on target '${target}'"; return 1;
    fi

    private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    private_MAIL_APPEND "User ${user} access to Target ${login}@${target} revoked"

    return 0;
  }

  TARGET_ACCESS_LIST_USERGROUPS () {
    local target= login=
    if [ $# -ne 1 -a $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 1 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
    else
      target="$1"; login="$2"
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi

    TARGET_SSH_LIST_LOGINS "${target}" | grep "^${login}$" >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Login '${login}' doesn't exist on target '${target}'"; return 1;
    fi

    cat "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}" | sort -u
    return 0;
  }

  TARGET_ACCESS_LIST_ALL_USERGROUPS () {
    local target= login=

    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    target=$( TARGET_REAL "$1" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist"; return 1;
    fi

    for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
      echo "= ${login}@${target} ="
      TARGET_ACCESS_LIST_USERGROUPS "${target}" "${login}"
    done
  }

  TARGET_ACCESS_ADD_USERGROUP () {
    local target= login= usergroup=
    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    if [ $# -eq 2 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
      usergroup="$2"
    else
      target="$1"; login="$2"; usergroup="$3"
    fi

    if [ -z "${usergroup}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_ADD "${usergroup}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}"
    private_MAIL_APPEND "User Group ${usergroup} access to Target ${login}@${target} granted"

    return 0;
  }

  TARGET_ACCESS_DEL_USERGROUP () {
    local target= login= usergroup=
    if [ $# -ne 2 -a $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1
    fi

    if [ $# -eq 2 ]; then
      target=$( GET_HOST "$1" )
      login=$( GET_LOGIN "$1" )
      usergroup="$2"
    else
      target="$1"; login="$2"; usergroup="$3"
    fi

    if [ -z "${usergroup}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    target=$( TARGET_REAL "${target}" )
    if [ -z "${target}" ]; then
      ERROR "Target  host '${target}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_DEL "${usergroup}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.${login}"
    private_MAIL_APPEND "User Group ${usergroup} access to Target ${login}@${target} revoked"

    return 0;
  }

  USERS_LIST () {
    local res= find_opt=
    [ $# -eq 1 ] && find_opt="-iname '$1'"

    res=$( eval "find '${SSHGATE_DIR_USERS}' -type f ${find_opt} -printf '%P\n'" )
    echo "${res}" | grep -v '[.]properties$' | sort -u
    return 0;
  }

  USER_ADD () {
    local user= userkey= usermail=
    if [ $# -ne 3 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    user="$1"; userkey="$2"; usermail="$3"
    if [ -z "${user}" -o -z "${userkey}" -o -z "${usermail}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ ! -r "${userkey}" ]; then
      ERROR "Can't read user ssh key" ; return 1;
    fi

    echo "${user}" | grep ' ' >/dev/null
    if [ $? -eq 0 -o -z "${user}" ]; then
      ERROR "${user} is not a valid username" ; return 1
    fi

    if [ -f "${SSHGATE_DIR_USERS}/${user}" ]; then
      ERROR "User '${user}' already exists" ; return 1;
    fi

    echo "${usermail}" | grep '@' >/dev/null
    if [ $? -ne 0 ]; then
      ERROR "Invalid user e-mail" ; return 1;
    fi

    cp "${userkey}" "${SSHGATE_DIR_USERS}/${user}"
    private_MAIL_APPEND "User ${user} added"
    USER_SET_CONF "${user}" MAIL "${usermail}"

    BUILD_AUTHORIZED_KEYS
    return 0
  }

  USER_DEL () {
    local user= usergroup=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1
    fi

    user="$1"
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist"  ; return 1;
    fi

    # delete user from groups
    for usergroup in $( USER_LIST_USERGROUPS "${user}" ); do
      private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"
    done

    # delete user from target access list
    for target in $( USER_LIST_TARGETS "${user}" ); do
      login=$( GET_LOGIN "${target}" )
      target=$( GET_HOST "${target}" )
      private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_TARGETS}/${target}/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.${login}"
    done

    rm -f "${SSHGATE_DIR_USERS}/${user}"
    rm -f "${SSHGATE_DIR_USERS}/${user}.properties"
    private_MAIL_APPEND "User ${user} removed"

    BUILD_AUTHORIZED_KEYS
    return 0
  }

  USER_DISPLAY_CONF () {
    local user= file=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    user="$1"
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist"; return 1;
    fi

    file="${SSHGATE_DIR_USERS}/${user}.properties"
    if [ ! -f "${file}" ]; then
      NOTICE "User '${user}' has no configuration file"
    else
      cat "${file}"
    fi
    return 0
  }

  USER_SET_CONF () {
    local user= var= value= file=
    if [ $# -lt 2 -o $# -gt 3 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    user="$1"; var="$2"
    [ $# -eq 3 ] && value="$3"

    if [ -z "${user}" -o -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist"; return 1;
    fi

    file="${SSHGATE_DIR_USERS}/${user}.properties"
    if [ -n "${value}" ]; then
      [ ! -f "${file}" ] && touch "${file}"
      chown "${SSHGATE_GATE_ACCOUNT}" "${file}" # ensure that sshgate.sh can read/write this file
      CONF_SAVE --conf-file "${file}" "${var}" "${value}"
      private_MAIL_APPEND "User '${user}' configuration: ${var} = ${value}"
    else
      CONF_DEL --conf-file "${file}" "${var}"
      [ ! -s "${file}" ] && rm -f "${file}"
      private_MAIL_APPEND "User '${user}' configuration: ${var} removed"
    fi

    [ -f "${file}" ] && chmod a+r "${file}" # ensure dans file permissions are good
    return 0;
  }

  USER_GET_CONF () {
    local user= var= file=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS; return 1;
    fi

    user="$1"; var="$2"

    if [ -z "${user}" -o -z "${var}" ]; then
      BAD_ARGUMENTS; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist"; return 1;
    fi

    file="${SSHGATE_DIR_USERS}/${user}.properties"
    if [ -f "${file}" ]; then
      CONF_GET --conf-file "${file}" "${var}"
      eval "echo \"\${${var}}\""
    fi
    return 0
  }

  USER_LIST_USERGROUPS () {
    local user= usergroup=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    user="$1"
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    for usergroup in $( grep -l -r "^${user}\$" "${SSHGATE_DIR_USERS_GROUPS}/" | sort -u ); do
      echo "${usergroup##*/}"
    done | sort -u
    return 0;
  }

  USER_LIST_TARGETS () {
    local user= target= is_restricted=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    user="$1"
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    is_restricted=$( USER_GET_CONF "${user}" IS_RESTRICTED )
    if [ "${is_restricted}" = 'false' ]; then
      for target in $( TARGETS_LIST ); do
        for login in $( TARGET_SSH_LIST_LOGINS "${target}" ); do
          echo "${login}@${target}"
        done
      done
    else
      ( # subshell :(
          # direct access
          for target in $( find "${SSHGATE_DIR_TARGETS}"                      \
                            -name "${SSHGATE_TARGETS_USER_ACCESS_FILENAME}*" \
                            -exec grep -l "^${user}\$" {} \; ); do
            target=$( echo "${target}" | sed -e "s|^.*/\([^/]*\)/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.\(.*\)$|\2@\1|" )
            echo "${target}"
          done

          # access through usergroup
          for usergroup in $( USER_LIST_USERGROUPS "${user}" ); do
            USERGROUP_LIST_TARGETS "${usergroup}"
          done
      ) | sort -u
    fi # end of : if [ "${is_restricted}" = 'false' ]; then
    return 0;
  }

  USER_ACCESS_INFO () {
    local user= target= usergroup= is_restricted=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    user="$1"
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    # direct access
    for target in $( find "${SSHGATE_DIR_TARGETS}"                     \
                      -name "${SSHGATE_TARGETS_USER_ACCESS_FILENAME}*" \
                      -exec grep -l "^${user}\$" {} \; | sort -u ); do
      target=$( echo "${target}" | sed -e "s|^.*/\([^/]*\)/${SSHGATE_TARGETS_USER_ACCESS_FILENAME}.\(.*\)$|\2@\1|" )
      echo "  ${user} ---> ${target}"
    done

    # access through usergroup
    for usergroup in $( USER_LIST_USERGROUPS "${user}" ); do
      for target in $( find "${SSHGATE_DIR_TARGETS}"                          \
                        -name "${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}*" \
                        -exec grep -l "^${usergroup}\$" {} \; | sort -u ); do
        target=$( echo "${target}" | sed -e "s|^.*/\([^/]*\)/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.\(.*\)$|\2@\1|" )
        echo "  ${user} --- usergroup(${usergroup}) ---> ${target}"
      done
    done

    is_restricted=$( USER_GET_CONF "${user}" IS_RESTRICTED )
    if [ "${is_restricted}" = 'false' ]; then
      echo
      echo "NOTICE: User has access to whole target host, as its configuration IS_RESTRICTED variable is set to 'false'.";
      echo
    fi
    return 0;
  }

  USER_ACCESS_NOTIFY () {
    local user= user_mail= mail_file= old_mail_file= aliases=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    user="$1"
    user_mail=$( USER_GET_CONF "${user}" MAIL )
    if [ -z "${user_mail}" ]; then
      ERROR "No e-mail was setup for user '${user}'"; return 1;
    fi

    old_mail_file=$( MAIL_GET_FILE )
    MAIL_CREATE

    MAIL_APPEND "Hi,"
    MAIL_APPEND ''
    MAIL_APPEND "Here is the list of your access of sshGate :"
    MAIL_APPEND ''
    for target in $( USER_LIST_TARGETS "${user}" ); do
      MAIL_APPEND " - ${target}"
      aliases=
      aliases=$( TARGET_LIST_ALIASES "${target}" )
      if [ "${aliases}" != '' ]; then
        aliases=$( echo "${aliases}" | tr $'\n' ',' )
        MAIL_APPEND "     alias: ${aliases}"
      fi
    done
    MAIL_SEND "Your sshGate access" "${user_mail}"

    MAIL_SET_FILE "${old_mail_file}"
    return 0
  }

  USERGROUPS_LIST () {
    local res= find_opt=
    [ $# -eq 1 ] && find_opt="-iname '$1'"
    res=$( eval "find '${SSHGATE_DIR_USERS_GROUPS}' -mindepth 1 -type f ${find_opt} -printf '%P\n'" )
    echo "${res}" | sort -u
    return 0;
  }

  USERGROUP_ADD () {
    local usergroup=

    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ -z "${usergroup}" ]; then
      BAD_ARGUMENTS ; return 1;
    fi
    if [ -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" ]; then
      ERROR "User group '${usergroup}' already exists" ; return 1
    fi

    touch "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"
    private_MAIL_APPEND "User Group ${usergroup} added"

    return 0;
  }

  USERGROUP_DEL () {
    local usergroup=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1
    fi

    for target in $( USERGROUP_LIST_TARGETS "${usergroup}" ); do
      TARGET_ACCESS_DEL_USERGROUP "${target}" "${usergroup}"
    done

    rm -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"
    private_MAIL_APPEND "User Group ${usergroup} removed"

    return 0
  }

  USERGROUP_LIST_USERS () {
    local usergroup=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    cat "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" | sort -u
    return 0;
  }

  USERGROUP_ADD_USER () {
    local usergroup= user=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"; user="$2";
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_ADD "${user}" "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"
    private_MAIL_APPEND "User ${user} added to User Group ${usergroup}"

    return 0;
  }

  USERGROUP_DEL_USER () {
    local usergroup= user=
    if [ $# -ne 2 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"; user="$2"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi
    if [ ! -f "${SSHGATE_DIR_USERS}/${user}" -o -z "${user}" ]; then
      ERROR "User '${user}' doesn't exist" ; return 1;
    fi

    private_ACL_FILE_DEL "${user}" "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}"
    private_MAIL_APPEND "User ${user} removed from User Group ${usergroup}"

    return 0;
  }

  USERGROUP_LIST_TARGETS () {
    local usergroup= target=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    for target in $( find "${SSHGATE_DIR_TARGETS}"                          \
                      -name "${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}*" \
                      -exec grep -l "^${usergroup}\$" {} \; | sort -u ); do
      target=$( echo "${target}" | sed -e "s|^.*/\([^/]*\)/${SSHGATE_TARGETS_USERGROUP_ACCESS_FILENAME}.\(.*\)$|\2@\1|" )
      echo "${target}"
    done | sort -u
    return 0;
  }

  USERGROUP_ACCESS_INFO () {
    local usergroup= users= targets=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    users=$(   USERGROUP_LIST_USERS "${usergroup}"   ); users=$(   echo -n "${users}"   | tr $'\n' ',' )
    targets=$( USERGROUP_LIST_TARGETS "${usergroup}" ); targets=$( echo -n "${targets}" | tr $'\n' ',' )
    echo "  ${users} --- usergroup(${usergroup}) ---> ${targets}"

    return 0;
  }

  USERGROUP_ACCESS_NOTIFY () {
    local usergroup= user=
    if [ $# -ne 1 ]; then
      BAD_ARGUMENTS ; return 1;
    fi

    usergroup="$1"
    if [ ! -f "${SSHGATE_DIR_USERS_GROUPS}/${usergroup}" -o -z "${usergroup}" ]; then
      ERROR "User group '${usergroup}' doesn't exist" ; return 1;
    fi

    for user in $( USERGROUP_LIST_USERS "${usergroup}" ); do
      USER_ACCESS_NOTIFY "${user}"
    done

    return 0;
  }

fi # __SSHGATE_FUNC__
